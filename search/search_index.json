{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n a los Algoritmos Este documento presenta los conceptos fundamentales sobre algoritmos , sus caracter\u00edsticas, elementos principales y la clasificaci\u00f3n de datos. La estructura y estilo sigue el enfoque de documentaci\u00f3n t\u00e9cnica de la MDN Web Docs . \u00bfQu\u00e9 es un Algoritmo? Un algoritmo es una secuencia finita de instrucciones, reglas o pasos que describen de modo preciso las operaciones que una computadora debe realizar para ejecutar una tarea en un tiempo finito\u301024\u2020source\u3011. Ejemplos de algoritmos en la vida real: Determinar en qu\u00e9 horario se realizan m\u00e1s publicaciones en enero. Calcular cu\u00e1ntas personas est\u00e1n en espera en determinado horario. Generar un ranking de los 5 pa\u00edses con m\u00e1s consultas\u301024\u2020source\u3011. Caracter\u00edsticas de un Algoritmo Un buen algoritmo debe ser: Preciso : cada paso debe estar claramente definido. Correcto : debe resolver el problema planteado. Definido : el mismo conjunto de datos de entrada debe producir siempre la misma salida. Finito : debe terminar en alg\u00fan momento\u301024\u2020source\u3011. Elementos de un Algoritmo Los algoritmos est\u00e1n compuestos por tres elementos principales\u301024\u2020source\u3011: Datos Informaci\u00f3n de entrada o salida. Se clasifican en distintos tipos. Acciones Operaciones que transforman los datos. Operadores Elementos que permiten construir expresiones o condiciones. Tipos de Datos Los datos representan informaci\u00f3n utilizada por los algoritmos. Se dividen en: Simples Num\u00e9ricos : representan cantidades o valores (ej: edad, salario). Alfanum\u00e9ricos : representan texto (ej: nombre, apellido). No se pueden operar matem\u00e1ticamente. L\u00f3gicos (booleanos) : s\u00f3lo pueden tomar dos valores (Verdadero/Falso). Ejemplo: estado de un sem\u00e1foro\u301024\u2020source\u3011. Estructurados Conjuntos de datos simples agrupados. Se ver\u00e1n m\u00e1s adelante (registros, secuencias, archivos). Variables y Constantes Variables Representan una direcci\u00f3n de memoria que puede cambiar durante la ejecuci\u00f3n del algoritmo. // Ejemplo de variables stock := 50 cantidad_estudiantes := 32 Constantes Representan una direcci\u00f3n de memoria cuyo contenido no cambia durante la ejecuci\u00f3n . // Ejemplo de constantes IVA := 0.21 PI := 3.14159 Acciones Una acci\u00f3n es un acontecimiento que ocurre en un tiempo finito y produce un cambio de estado\u301024\u2020source\u3011. Tipos de acciones Asignaci\u00f3n : asignar un valor a una variable. Condicionales : tomar decisiones seg\u00fan una condici\u00f3n. Repetitivas : ejecutar un bloque varias veces. Con nombre : agrupaciones de instrucciones (subacciones, funciones, procedimientos). Asignaci\u00f3n La asignaci\u00f3n reemplaza el valor anterior de una variable por un nuevo valor. Es una acci\u00f3n destructiva, ya que se pierde el valor previo\u301024\u2020source\u3011. Ejemplo: Asignaci\u00f3n Pura // Ejemplo de sem\u00e1foro semaforo := \"Rojo\" semaforo := \"Verde\" semaforo := \"Amarillo\" Ejemplo: Asignaci\u00f3n de Expresi\u00f3n Algebraica descuento := importe / 2 Ejemplo: Asignaci\u00f3n de Funci\u00f3n examen := REDOND(puntaje) Ejemplo: Contadores y Acumuladores billetes := billetes + 1 // contador dinero := dinero + billete // acumulador","title":"Introducci\u022fn"},{"location":"#introduccion-a-los-algoritmos","text":"Este documento presenta los conceptos fundamentales sobre algoritmos , sus caracter\u00edsticas, elementos principales y la clasificaci\u00f3n de datos. La estructura y estilo sigue el enfoque de documentaci\u00f3n t\u00e9cnica de la MDN Web Docs .","title":"Introducci\u00f3n a los Algoritmos"},{"location":"#que-es-un-algoritmo","text":"Un algoritmo es una secuencia finita de instrucciones, reglas o pasos que describen de modo preciso las operaciones que una computadora debe realizar para ejecutar una tarea en un tiempo finito\u301024\u2020source\u3011. Ejemplos de algoritmos en la vida real: Determinar en qu\u00e9 horario se realizan m\u00e1s publicaciones en enero. Calcular cu\u00e1ntas personas est\u00e1n en espera en determinado horario. Generar un ranking de los 5 pa\u00edses con m\u00e1s consultas\u301024\u2020source\u3011.","title":"\u00bfQu\u00e9 es un Algoritmo?"},{"location":"#caracteristicas-de-un-algoritmo","text":"Un buen algoritmo debe ser: Preciso : cada paso debe estar claramente definido. Correcto : debe resolver el problema planteado. Definido : el mismo conjunto de datos de entrada debe producir siempre la misma salida. Finito : debe terminar en alg\u00fan momento\u301024\u2020source\u3011.","title":"Caracter\u00edsticas de un Algoritmo"},{"location":"#elementos-de-un-algoritmo","text":"Los algoritmos est\u00e1n compuestos por tres elementos principales\u301024\u2020source\u3011: Datos Informaci\u00f3n de entrada o salida. Se clasifican en distintos tipos. Acciones Operaciones que transforman los datos. Operadores Elementos que permiten construir expresiones o condiciones.","title":"Elementos de un Algoritmo"},{"location":"#tipos-de-datos","text":"Los datos representan informaci\u00f3n utilizada por los algoritmos. Se dividen en:","title":"Tipos de Datos"},{"location":"#simples","text":"Num\u00e9ricos : representan cantidades o valores (ej: edad, salario). Alfanum\u00e9ricos : representan texto (ej: nombre, apellido). No se pueden operar matem\u00e1ticamente. L\u00f3gicos (booleanos) : s\u00f3lo pueden tomar dos valores (Verdadero/Falso). Ejemplo: estado de un sem\u00e1foro\u301024\u2020source\u3011.","title":"Simples"},{"location":"#estructurados","text":"Conjuntos de datos simples agrupados. Se ver\u00e1n m\u00e1s adelante (registros, secuencias, archivos).","title":"Estructurados"},{"location":"#variables-y-constantes","text":"","title":"Variables y Constantes"},{"location":"#variables","text":"Representan una direcci\u00f3n de memoria que puede cambiar durante la ejecuci\u00f3n del algoritmo. // Ejemplo de variables stock := 50 cantidad_estudiantes := 32","title":"Variables"},{"location":"#constantes","text":"Representan una direcci\u00f3n de memoria cuyo contenido no cambia durante la ejecuci\u00f3n . // Ejemplo de constantes IVA := 0.21 PI := 3.14159","title":"Constantes"},{"location":"#acciones","text":"Una acci\u00f3n es un acontecimiento que ocurre en un tiempo finito y produce un cambio de estado\u301024\u2020source\u3011.","title":"Acciones"},{"location":"#tipos-de-acciones","text":"Asignaci\u00f3n : asignar un valor a una variable. Condicionales : tomar decisiones seg\u00fan una condici\u00f3n. Repetitivas : ejecutar un bloque varias veces. Con nombre : agrupaciones de instrucciones (subacciones, funciones, procedimientos).","title":"Tipos de acciones"},{"location":"#asignacion","text":"La asignaci\u00f3n reemplaza el valor anterior de una variable por un nuevo valor. Es una acci\u00f3n destructiva, ya que se pierde el valor previo\u301024\u2020source\u3011.","title":"Asignaci\u00f3n"},{"location":"#ejemplo-asignacion-pura","text":"// Ejemplo de sem\u00e1foro semaforo := \"Rojo\" semaforo := \"Verde\" semaforo := \"Amarillo\"","title":"Ejemplo: Asignaci\u00f3n Pura"},{"location":"#ejemplo-asignacion-de-expresion-algebraica","text":"descuento := importe / 2","title":"Ejemplo: Asignaci\u00f3n de Expresi\u00f3n Algebraica"},{"location":"#ejemplo-asignacion-de-funcion","text":"examen := REDOND(puntaje)","title":"Ejemplo: Asignaci\u00f3n de Funci\u00f3n"},{"location":"#ejemplo-contadores-y-acumuladores","text":"billetes := billetes + 1 // contador dinero := dinero + billete // acumulador","title":"Ejemplo: Contadores y Acumuladores"},{"location":"02-secuenciales-condicionales/","text":"Estructuras Secuenciales y Condicionales Este documento presenta las estructuras de control secuenciales y condicionales , con teor\u00eda, ejemplos y pseudoc\u00f3digo. El estilo sigue la estructura de documentaci\u00f3n t\u00e9cnica inspirada en la MDN. Estructuras de Control Las estructuras de control determinan el orden en el que se ejecutan las instrucciones de un algoritmo. Caracter\u00edsticas: Cada estructura tiene un \u00fanico punto de entrada y un \u00fanico punto de salida . Puede estar formada por sentencias o por otras estructuras de control\u301025\u2020source\u3011. Estructuras Secuenciales La ejecuci\u00f3n comienza con la primera instrucci\u00f3n del algoritmo y contin\u00faa en orden hasta la \u00faltima. Cada sentencia se ejecuta una sola vez \u301025\u2020source\u3011. Ejemplo: c\u00e1lculo de porcentaje Problema: Dado un importe, obtener su 10%. Accion Porcentaje Es Ambiente importe: numerico Proceso Esc(\"Ingrese importe\") Leer(importe) Esc(\"El 10% es\", 10*importe/100) Fin Accion Estructuras Condicionales Cuando es necesario tomar decisiones en un algoritmo, se utilizan estructuras condicionales. Se basan en la evaluaci\u00f3n de una expresi\u00f3n l\u00f3gica \u301025\u2020source\u3011. Tipos de condicionales Simple : una sola acci\u00f3n si se cumple la condici\u00f3n. Alternativa (doble) : una acci\u00f3n si se cumple, otra si no. M\u00faltiple : varias alternativas seg\u00fan el valor de una expresi\u00f3n. Condicional Simple Ejecuta una serie de instrucciones solo si la condici\u00f3n es verdadera. Si condicion_se_cumple Entonces accion_1 accion_2 FinSi Ejemplo: Verificar si un n\u00famero es positivo. Accion EjemploCS Es Ambiente x: numerico Proceso Esc(\"Ingrese un valor\") Leer(x) Si x > 0 Entonces Esc(\"El n\u00famero es positivo\") FinSi Fin Accion Condicional Alternativa Permite ejecutar un bloque si la condici\u00f3n se cumple, y otro bloque si no se cumple. Si condicion Entonces acciones_si Contrario acciones_no FinSi Ejemplo: Comparar dos n\u00fameros. Accion MayorMenor Es Ambiente a, b: numerico Proceso Esc(\"Ingrese primer n\u00famero\") Leer(a) Esc(\"Ingrese segundo n\u00famero\") Leer(b) Si a > b Entonces Esc(\"El primero es mayor\") Contrario Esc(\"El segundo es mayor o igual\") FinSi Fin Accion Condicional M\u00faltiple Permite elegir entre varias alternativas seg\u00fan el valor de una variable o expresi\u00f3n. Segun variable Hacer valor1: acciones_1 valor2: acciones_2 Otro: acciones_defecto FinSegun Ejemplo: Determinar la estaci\u00f3n del a\u00f1o a partir de un n\u00famero de mes. Accion Estacion Es Ambiente mes: entero Proceso Esc(\"Ingrese un n\u00famero de mes\") Leer(mes) Segun mes Hacer 12,1,2: Esc(\"Verano\") 3,4,5: Esc(\"Oto\u00f1o\") 6,7,8: Esc(\"Invierno\") 9,10,11: Esc(\"Primavera\") Otro: Esc(\"Mes inv\u00e1lido\") FinSegun Fin Accion Resumen Secuenciales : todas las instrucciones se ejecutan en orden. Condicionales simples : ejecutan acciones solo si la condici\u00f3n es verdadera. Condicionales alternativas : permiten un camino u otro. Condicionales m\u00faltiples : seleccionan entre varias opciones. Estas estructuras son la base para controlar el flujo de cualquier algoritmo.","title":"Condicionales"},{"location":"02-secuenciales-condicionales/#estructuras-secuenciales-y-condicionales","text":"Este documento presenta las estructuras de control secuenciales y condicionales , con teor\u00eda, ejemplos y pseudoc\u00f3digo. El estilo sigue la estructura de documentaci\u00f3n t\u00e9cnica inspirada en la MDN.","title":"Estructuras Secuenciales y Condicionales"},{"location":"02-secuenciales-condicionales/#estructuras-de-control","text":"Las estructuras de control determinan el orden en el que se ejecutan las instrucciones de un algoritmo. Caracter\u00edsticas: Cada estructura tiene un \u00fanico punto de entrada y un \u00fanico punto de salida . Puede estar formada por sentencias o por otras estructuras de control\u301025\u2020source\u3011.","title":"Estructuras de Control"},{"location":"02-secuenciales-condicionales/#estructuras-secuenciales","text":"La ejecuci\u00f3n comienza con la primera instrucci\u00f3n del algoritmo y contin\u00faa en orden hasta la \u00faltima. Cada sentencia se ejecuta una sola vez \u301025\u2020source\u3011.","title":"Estructuras Secuenciales"},{"location":"02-secuenciales-condicionales/#ejemplo-calculo-de-porcentaje","text":"Problema: Dado un importe, obtener su 10%. Accion Porcentaje Es Ambiente importe: numerico Proceso Esc(\"Ingrese importe\") Leer(importe) Esc(\"El 10% es\", 10*importe/100) Fin Accion","title":"Ejemplo: c\u00e1lculo de porcentaje"},{"location":"02-secuenciales-condicionales/#estructuras-condicionales","text":"Cuando es necesario tomar decisiones en un algoritmo, se utilizan estructuras condicionales. Se basan en la evaluaci\u00f3n de una expresi\u00f3n l\u00f3gica \u301025\u2020source\u3011.","title":"Estructuras Condicionales"},{"location":"02-secuenciales-condicionales/#tipos-de-condicionales","text":"Simple : una sola acci\u00f3n si se cumple la condici\u00f3n. Alternativa (doble) : una acci\u00f3n si se cumple, otra si no. M\u00faltiple : varias alternativas seg\u00fan el valor de una expresi\u00f3n.","title":"Tipos de condicionales"},{"location":"02-secuenciales-condicionales/#condicional-simple","text":"Ejecuta una serie de instrucciones solo si la condici\u00f3n es verdadera. Si condicion_se_cumple Entonces accion_1 accion_2 FinSi Ejemplo: Verificar si un n\u00famero es positivo. Accion EjemploCS Es Ambiente x: numerico Proceso Esc(\"Ingrese un valor\") Leer(x) Si x > 0 Entonces Esc(\"El n\u00famero es positivo\") FinSi Fin Accion","title":"Condicional Simple"},{"location":"02-secuenciales-condicionales/#condicional-alternativa","text":"Permite ejecutar un bloque si la condici\u00f3n se cumple, y otro bloque si no se cumple. Si condicion Entonces acciones_si Contrario acciones_no FinSi Ejemplo: Comparar dos n\u00fameros. Accion MayorMenor Es Ambiente a, b: numerico Proceso Esc(\"Ingrese primer n\u00famero\") Leer(a) Esc(\"Ingrese segundo n\u00famero\") Leer(b) Si a > b Entonces Esc(\"El primero es mayor\") Contrario Esc(\"El segundo es mayor o igual\") FinSi Fin Accion","title":"Condicional Alternativa"},{"location":"02-secuenciales-condicionales/#condicional-multiple","text":"Permite elegir entre varias alternativas seg\u00fan el valor de una variable o expresi\u00f3n. Segun variable Hacer valor1: acciones_1 valor2: acciones_2 Otro: acciones_defecto FinSegun Ejemplo: Determinar la estaci\u00f3n del a\u00f1o a partir de un n\u00famero de mes. Accion Estacion Es Ambiente mes: entero Proceso Esc(\"Ingrese un n\u00famero de mes\") Leer(mes) Segun mes Hacer 12,1,2: Esc(\"Verano\") 3,4,5: Esc(\"Oto\u00f1o\") 6,7,8: Esc(\"Invierno\") 9,10,11: Esc(\"Primavera\") Otro: Esc(\"Mes inv\u00e1lido\") FinSegun Fin Accion","title":"Condicional M\u00faltiple"},{"location":"02-secuenciales-condicionales/#resumen","text":"Secuenciales : todas las instrucciones se ejecutan en orden. Condicionales simples : ejecutan acciones solo si la condici\u00f3n es verdadera. Condicionales alternativas : permiten un camino u otro. Condicionales m\u00faltiples : seleccionan entre varias opciones. Estas estructuras son la base para controlar el flujo de cualquier algoritmo.","title":"Resumen"},{"location":"03-repetitivas/","text":"Estructuras Repetitivas Este documento explica las estructuras repetitivas (o ciclos), junto con los recursos b\u00e1sicos necesarios: contadores, acumuladores y banderas . Se incluyen ejemplos de pseudoc\u00f3digo siguiendo el estilo de documentaci\u00f3n t\u00e9cnica inspirada en MDN. Recursos Fundamentales Contadores Son variables que llevan la cuenta de cu\u00e1ntas veces ocurre un evento. Se incrementan o decrementan en valores constantes. contador := contador + 1 Ejemplo: Sensor de aforo que incrementa cada vez que entra una persona. Acumuladores Son variables que suman cantidades variables (no constantes). Sirven para almacenar totales. acumula := acumula + valor Ejemplo: Robot que acumula kilos de basura espacial recolectados. Banderas Son variables l\u00f3gicas (booleanas) que indican si ocurri\u00f3 o no un evento. bandera := V // verdadero bandera := F // falso Ejemplo: Encender o apagar luces seg\u00fan el horario configurado (7PM a 6AM). Concepto de Iteraci\u00f3n La iteraci\u00f3n es la repetici\u00f3n de un conjunto de acciones bajo ciertas condiciones. Cada vuelta del ciclo se denomina bucle \u301016\u2020source\u3011. Clasificaci\u00f3n de Ciclos Definidos : sabemos de antemano cu\u00e1ntas veces se repite. Ejemplo: ejecutar una acci\u00f3n 10 veces. Indefinidos : no sabemos la cantidad exacta de repeticiones. Ejemplo: pedir n\u00fameros hasta que se ingrese un valor negativo. Los ciclos tambi\u00e9n se clasifican en Pre-Test y Post-Test seg\u00fan el momento en que se eval\u00faa la condici\u00f3n\u301016\u2020source\u3011. Ciclo Pre-Test La condici\u00f3n se eval\u00faa antes de ejecutar el bloque. Puede repetirse 0 o m\u00e1s veces. total := 0 Esc(\"Ingrese primer n\u00famero\") Leer(num) Mientras num >= 0 Hacer total := total + num Esc(\"Ingrese otro n\u00famero\") Leer(num) FinMientras Esc(\"La suma total es\", total) Ejemplo real: sumar los n\u00fameros ingresados en un juego hasta que el usuario escriba un valor negativo. Ciclo Post-Test La condici\u00f3n se eval\u00faa despu\u00e9s de ejecutar el bloque. Garantiza al menos una ejecuci\u00f3n. clavecorrecta := 123 Repetir Esc(\"Introduce la clave\") Leer(intento) Hasta que intento = clavecorrecta Ejemplo real: pedir una contrase\u00f1a hasta que coincida con la correcta. Ciclo Definido por Contador Se utiliza cuando se conoce de antemano la cantidad de repeticiones. Generalmente implementado con PARA . Para i := 1 Hasta 5 Hacer Esc(\"Iteraci\u00f3n n\u00famero\", i) FinPara Ejemplo real: mostrar un mensaje 5 veces. Resumen Contadores, acumuladores y banderas son recursos b\u00e1sicos para construir algoritmos repetitivos. Pre-Test : condici\u00f3n antes del bloque (0 o m\u00e1s repeticiones). Post-Test : condici\u00f3n despu\u00e9s del bloque (1 o m\u00e1s repeticiones). Definidos por contador : n\u00famero de repeticiones conocidas de antemano. Estas estructuras son esenciales para automatizar procesos donde la repetici\u00f3n es necesaria.","title":"Repetitivas"},{"location":"03-repetitivas/#estructuras-repetitivas","text":"Este documento explica las estructuras repetitivas (o ciclos), junto con los recursos b\u00e1sicos necesarios: contadores, acumuladores y banderas . Se incluyen ejemplos de pseudoc\u00f3digo siguiendo el estilo de documentaci\u00f3n t\u00e9cnica inspirada en MDN.","title":"Estructuras Repetitivas"},{"location":"03-repetitivas/#recursos-fundamentales","text":"","title":"Recursos Fundamentales"},{"location":"03-repetitivas/#contadores","text":"Son variables que llevan la cuenta de cu\u00e1ntas veces ocurre un evento. Se incrementan o decrementan en valores constantes. contador := contador + 1 Ejemplo: Sensor de aforo que incrementa cada vez que entra una persona.","title":"Contadores"},{"location":"03-repetitivas/#acumuladores","text":"Son variables que suman cantidades variables (no constantes). Sirven para almacenar totales. acumula := acumula + valor Ejemplo: Robot que acumula kilos de basura espacial recolectados.","title":"Acumuladores"},{"location":"03-repetitivas/#banderas","text":"Son variables l\u00f3gicas (booleanas) que indican si ocurri\u00f3 o no un evento. bandera := V // verdadero bandera := F // falso Ejemplo: Encender o apagar luces seg\u00fan el horario configurado (7PM a 6AM).","title":"Banderas"},{"location":"03-repetitivas/#concepto-de-iteracion","text":"La iteraci\u00f3n es la repetici\u00f3n de un conjunto de acciones bajo ciertas condiciones. Cada vuelta del ciclo se denomina bucle \u301016\u2020source\u3011.","title":"Concepto de Iteraci\u00f3n"},{"location":"03-repetitivas/#clasificacion-de-ciclos","text":"Definidos : sabemos de antemano cu\u00e1ntas veces se repite. Ejemplo: ejecutar una acci\u00f3n 10 veces. Indefinidos : no sabemos la cantidad exacta de repeticiones. Ejemplo: pedir n\u00fameros hasta que se ingrese un valor negativo. Los ciclos tambi\u00e9n se clasifican en Pre-Test y Post-Test seg\u00fan el momento en que se eval\u00faa la condici\u00f3n\u301016\u2020source\u3011.","title":"Clasificaci\u00f3n de Ciclos"},{"location":"03-repetitivas/#ciclo-pre-test","text":"La condici\u00f3n se eval\u00faa antes de ejecutar el bloque. Puede repetirse 0 o m\u00e1s veces. total := 0 Esc(\"Ingrese primer n\u00famero\") Leer(num) Mientras num >= 0 Hacer total := total + num Esc(\"Ingrese otro n\u00famero\") Leer(num) FinMientras Esc(\"La suma total es\", total) Ejemplo real: sumar los n\u00fameros ingresados en un juego hasta que el usuario escriba un valor negativo.","title":"Ciclo Pre-Test"},{"location":"03-repetitivas/#ciclo-post-test","text":"La condici\u00f3n se eval\u00faa despu\u00e9s de ejecutar el bloque. Garantiza al menos una ejecuci\u00f3n. clavecorrecta := 123 Repetir Esc(\"Introduce la clave\") Leer(intento) Hasta que intento = clavecorrecta Ejemplo real: pedir una contrase\u00f1a hasta que coincida con la correcta.","title":"Ciclo Post-Test"},{"location":"03-repetitivas/#ciclo-definido-por-contador","text":"Se utiliza cuando se conoce de antemano la cantidad de repeticiones. Generalmente implementado con PARA . Para i := 1 Hasta 5 Hacer Esc(\"Iteraci\u00f3n n\u00famero\", i) FinPara Ejemplo real: mostrar un mensaje 5 veces.","title":"Ciclo Definido por Contador"},{"location":"03-repetitivas/#resumen","text":"Contadores, acumuladores y banderas son recursos b\u00e1sicos para construir algoritmos repetitivos. Pre-Test : condici\u00f3n antes del bloque (0 o m\u00e1s repeticiones). Post-Test : condici\u00f3n despu\u00e9s del bloque (1 o m\u00e1s repeticiones). Definidos por contador : n\u00famero de repeticiones conocidas de antemano. Estas estructuras son esenciales para automatizar procesos donde la repetici\u00f3n es necesaria.","title":"Resumen"},{"location":"04-funciones-procedimientos/","text":"Subacciones: Funciones y Procedimientos En esta p\u00e1gina se describen las subacciones y sus dos formas principales: funciones y procedimientos . Se cubren conceptos, reglas de dise\u00f1o, sintaxis de pseudoc\u00f3digo y ejemplos completos. Visi\u00f3n general Subacci\u00f3n : m\u00f3dulo que realiza una tarea espec\u00edfica dentro de una acci\u00f3n principal . Se escribe una sola vez y puede invocarse m\u00faltiples veces desde el algoritmo principal o desde otras subacciones. Mejora la legibilidad, reutilizaci\u00f3n y mantenimiento (estrategia de divide y vencer\u00e1s ). Control de ejecuci\u00f3n Cuando el algoritmo principal llama a una subacci\u00f3n: Se detiene la ejecuci\u00f3n del llamador. Se ejecuta la subacci\u00f3n hasta finalizar su tarea. El control retorna al punto siguiente a la llamada. Este comportamiento aplica tanto a funciones como a procedimientos. Elementos de una subacci\u00f3n Nombre Debe ser representativo del objetivo del m\u00f3dulo. Debe ser \u00fanico y no debe colisionar con palabras reservadas del pseudolenguaje. Par\u00e1metros Mecanismo para pasar datos entre el algoritmo principal y la subacci\u00f3n. Pueden ser de entrada (datos que recibe) y/o salida (datos que devuelve por referencia o por resultado, seg\u00fan el modelo did\u00e1ctico que uses). Reglas pr\u00e1cticas de par\u00e1metros Cantidad : el n\u00famero de par\u00e1metros formales debe coincidir con el de argumentos al invocar. Orden y tipos : los par\u00e1metros en la llamada deben ser compatibles en tipo y posici\u00f3n con los formales. Procedimientos Un procedimiento es una subacci\u00f3n que no devuelve un valor como resultado de la llamada. Puede modificar par\u00e1metros de salida y/o producir efectos (por ejemplo, imprimir o escribir en una estructura). Plantilla (pseudoc\u00f3digo) SUBACCI\u00d3N NombreProcedimiento(par\u00e1metros_formales) ES // Declaraciones locales (si fueran necesarias) // Acciones FINSUBACCI\u00d3N Ejemplo: Lectura de entradas SUBACCI\u00d3N ObtenerEntradas ES Esc(\"Ingrese valor\") Leer(valor) FINSUBACCI\u00d3N ACCION Principal ES AMBIENTE valor: entero PROCESO ObtenerEntradas // ... seguir usando 'valor' FINACCION Funciones Una funci\u00f3n es una subacci\u00f3n que recibe argumentos y devuelve un \u00fanico resultado . Suele usarse dentro de expresiones o asignaciones. Plantilla (pseudoc\u00f3digo) FUNCION NombreFuncion(par\u00e1metros_formales): TipoDevuelto // Declaraciones locales (si fueran necesarias) // Acciones NombreFuncion := <expresi\u00f3n_resultado> FINFUNCION Ejemplo 1: Mayor de 3 FUNCION MayorDe3(a,b,c: entero): entero Si a >= b y a >= c Entonces MayorDe3 := a Contrario Si b >= a y b >= c Entonces MayorDe3 := b Contrario MayorDe3 := c FinSi FinSi FINFUNCION Ejemplo 2: Dos d\u00edgitos iguales (correcci\u00f3n de retorno) Dado un n\u00famero de 2 cifras, determinar si es pal\u00edndromo (igual le\u00eddo al derecho y al rev\u00e9s). Devuelve 1 si lo es, 0 si no. FUNCION DosCifrasIguales(n: entero): entero // Separar decenas y unidades dec := n DIV 10 uni := n MOD 10 Si dec = uni Entonces DosCifrasIguales := 1 Contrario DosCifrasIguales := 0 FinSi FINFUNCION Par\u00e1metros de entrada y salida Terminolog\u00eda \u00fatil Formales (o ficticios): se declaran en la definici\u00f3n del m\u00f3dulo. Actuales (o argumentos): se suministran en la llamada . Ejemplo: Contar pares con procedimiento auxiliar SUBACCI\u00d3N ContarPares(n: entero; pares: entero) ES // 'pares' act\u00faa como salida (por referencia en el modelo did\u00e1ctico) Si (n MOD 2 = 0) Entonces pares := pares + 1 FinSi FINSUBACCI\u00d3N ACCION Principal ES AMBIENTE i, v, pares: entero PROCESO pares := 0 Para i := 1 Hasta 100 Hacer Leer(v) ContarPares(v, pares) FinPara Esc(\"Cantidad de n\u00fameros pares:\", pares) FINACCION Ejemplo: Uso de funci\u00f3n dentro de un algoritmo ACCION SerieDosCifras ES AMBIENTE i, v, cant: entero PROCESO cant := 0 Para i := 1 Hasta 20 Hacer Leer(v) cant := cant + DosCifrasIguales(v) FinPara Esc(\"Cantidad de pal\u00edndromos de 2 d\u00edgitos:\", cant) FINACCION Buenas pr\u00e1cticas Nombres claros : describen qu\u00e9 hace la subacci\u00f3n (por ejemplo, CalcularPromedio en lugar de Proc1 ). Responsabilidad \u00fanica : cada subacci\u00f3n debe resolver una tarea concreta . Evitar efectos colaterales inesperados: documenta qu\u00e9 par\u00e1metros son de entrada/salida. Validaciones : comprueba supuestos (por ejemplo, dominios de entrada) al inicio del m\u00f3dulo. Errores frecuentes (y c\u00f3mo evitarlos) No asignar el valor de la funci\u00f3n antes de FINFUNCION \u2192 Asegur\u00e1 siempre NombreFuncion := ... . Desorden o cantidad incorrecta de par\u00e1metros \u2192 Verific\u00e1 orden, cantidad y tipos. Nombres ambiguos o reservados \u2192 Eleg\u00ed identificadores v\u00e1lidos y expresivos. Resumen Las subacciones encapsulan tareas y favorecen dise\u00f1o modular. Procedimientos : no devuelven valor; pueden producir efectos y modificar par\u00e1metros de salida. Funciones : devuelven un \u00fanico resultado y son \u00fatiles dentro de expresiones. Gestion\u00e1 correctamente nombres y par\u00e1metros (cantidad, orden, tipo) para llamadas seguras.","title":"Funciones y Procedimientos"},{"location":"04-funciones-procedimientos/#subacciones-funciones-y-procedimientos","text":"En esta p\u00e1gina se describen las subacciones y sus dos formas principales: funciones y procedimientos . Se cubren conceptos, reglas de dise\u00f1o, sintaxis de pseudoc\u00f3digo y ejemplos completos.","title":"Subacciones: Funciones y Procedimientos"},{"location":"04-funciones-procedimientos/#vision-general","text":"Subacci\u00f3n : m\u00f3dulo que realiza una tarea espec\u00edfica dentro de una acci\u00f3n principal . Se escribe una sola vez y puede invocarse m\u00faltiples veces desde el algoritmo principal o desde otras subacciones. Mejora la legibilidad, reutilizaci\u00f3n y mantenimiento (estrategia de divide y vencer\u00e1s ).","title":"Visi\u00f3n general"},{"location":"04-funciones-procedimientos/#control-de-ejecucion","text":"Cuando el algoritmo principal llama a una subacci\u00f3n: Se detiene la ejecuci\u00f3n del llamador. Se ejecuta la subacci\u00f3n hasta finalizar su tarea. El control retorna al punto siguiente a la llamada. Este comportamiento aplica tanto a funciones como a procedimientos.","title":"Control de ejecuci\u00f3n"},{"location":"04-funciones-procedimientos/#elementos-de-una-subaccion","text":"Nombre Debe ser representativo del objetivo del m\u00f3dulo. Debe ser \u00fanico y no debe colisionar con palabras reservadas del pseudolenguaje. Par\u00e1metros Mecanismo para pasar datos entre el algoritmo principal y la subacci\u00f3n. Pueden ser de entrada (datos que recibe) y/o salida (datos que devuelve por referencia o por resultado, seg\u00fan el modelo did\u00e1ctico que uses).","title":"Elementos de una subacci\u00f3n"},{"location":"04-funciones-procedimientos/#reglas-practicas-de-parametros","text":"Cantidad : el n\u00famero de par\u00e1metros formales debe coincidir con el de argumentos al invocar. Orden y tipos : los par\u00e1metros en la llamada deben ser compatibles en tipo y posici\u00f3n con los formales.","title":"Reglas pr\u00e1cticas de par\u00e1metros"},{"location":"04-funciones-procedimientos/#procedimientos","text":"Un procedimiento es una subacci\u00f3n que no devuelve un valor como resultado de la llamada. Puede modificar par\u00e1metros de salida y/o producir efectos (por ejemplo, imprimir o escribir en una estructura).","title":"Procedimientos"},{"location":"04-funciones-procedimientos/#plantilla-pseudocodigo","text":"SUBACCI\u00d3N NombreProcedimiento(par\u00e1metros_formales) ES // Declaraciones locales (si fueran necesarias) // Acciones FINSUBACCI\u00d3N","title":"Plantilla (pseudoc\u00f3digo)"},{"location":"04-funciones-procedimientos/#ejemplo-lectura-de-entradas","text":"SUBACCI\u00d3N ObtenerEntradas ES Esc(\"Ingrese valor\") Leer(valor) FINSUBACCI\u00d3N ACCION Principal ES AMBIENTE valor: entero PROCESO ObtenerEntradas // ... seguir usando 'valor' FINACCION","title":"Ejemplo: Lectura de entradas"},{"location":"04-funciones-procedimientos/#funciones","text":"Una funci\u00f3n es una subacci\u00f3n que recibe argumentos y devuelve un \u00fanico resultado . Suele usarse dentro de expresiones o asignaciones.","title":"Funciones"},{"location":"04-funciones-procedimientos/#plantilla-pseudocodigo_1","text":"FUNCION NombreFuncion(par\u00e1metros_formales): TipoDevuelto // Declaraciones locales (si fueran necesarias) // Acciones NombreFuncion := <expresi\u00f3n_resultado> FINFUNCION","title":"Plantilla (pseudoc\u00f3digo)"},{"location":"04-funciones-procedimientos/#ejemplo-1-mayor-de-3","text":"FUNCION MayorDe3(a,b,c: entero): entero Si a >= b y a >= c Entonces MayorDe3 := a Contrario Si b >= a y b >= c Entonces MayorDe3 := b Contrario MayorDe3 := c FinSi FinSi FINFUNCION","title":"Ejemplo 1: Mayor de 3"},{"location":"04-funciones-procedimientos/#ejemplo-2-dos-digitos-iguales-correccion-de-retorno","text":"Dado un n\u00famero de 2 cifras, determinar si es pal\u00edndromo (igual le\u00eddo al derecho y al rev\u00e9s). Devuelve 1 si lo es, 0 si no. FUNCION DosCifrasIguales(n: entero): entero // Separar decenas y unidades dec := n DIV 10 uni := n MOD 10 Si dec = uni Entonces DosCifrasIguales := 1 Contrario DosCifrasIguales := 0 FinSi FINFUNCION","title":"Ejemplo 2: Dos d\u00edgitos iguales (correcci\u00f3n de retorno)"},{"location":"04-funciones-procedimientos/#parametros-de-entrada-y-salida","text":"","title":"Par\u00e1metros de entrada y salida"},{"location":"04-funciones-procedimientos/#terminologia-util","text":"Formales (o ficticios): se declaran en la definici\u00f3n del m\u00f3dulo. Actuales (o argumentos): se suministran en la llamada .","title":"Terminolog\u00eda \u00fatil"},{"location":"04-funciones-procedimientos/#ejemplo-contar-pares-con-procedimiento-auxiliar","text":"SUBACCI\u00d3N ContarPares(n: entero; pares: entero) ES // 'pares' act\u00faa como salida (por referencia en el modelo did\u00e1ctico) Si (n MOD 2 = 0) Entonces pares := pares + 1 FinSi FINSUBACCI\u00d3N ACCION Principal ES AMBIENTE i, v, pares: entero PROCESO pares := 0 Para i := 1 Hasta 100 Hacer Leer(v) ContarPares(v, pares) FinPara Esc(\"Cantidad de n\u00fameros pares:\", pares) FINACCION","title":"Ejemplo: Contar pares con procedimiento auxiliar"},{"location":"04-funciones-procedimientos/#ejemplo-uso-de-funcion-dentro-de-un-algoritmo","text":"ACCION SerieDosCifras ES AMBIENTE i, v, cant: entero PROCESO cant := 0 Para i := 1 Hasta 20 Hacer Leer(v) cant := cant + DosCifrasIguales(v) FinPara Esc(\"Cantidad de pal\u00edndromos de 2 d\u00edgitos:\", cant) FINACCION","title":"Ejemplo: Uso de funci\u00f3n dentro de un algoritmo"},{"location":"04-funciones-procedimientos/#buenas-practicas","text":"Nombres claros : describen qu\u00e9 hace la subacci\u00f3n (por ejemplo, CalcularPromedio en lugar de Proc1 ). Responsabilidad \u00fanica : cada subacci\u00f3n debe resolver una tarea concreta . Evitar efectos colaterales inesperados: documenta qu\u00e9 par\u00e1metros son de entrada/salida. Validaciones : comprueba supuestos (por ejemplo, dominios de entrada) al inicio del m\u00f3dulo.","title":"Buenas pr\u00e1cticas"},{"location":"04-funciones-procedimientos/#errores-frecuentes-y-como-evitarlos","text":"No asignar el valor de la funci\u00f3n antes de FINFUNCION \u2192 Asegur\u00e1 siempre NombreFuncion := ... . Desorden o cantidad incorrecta de par\u00e1metros \u2192 Verific\u00e1 orden, cantidad y tipos. Nombres ambiguos o reservados \u2192 Eleg\u00ed identificadores v\u00e1lidos y expresivos.","title":"Errores frecuentes (y c\u00f3mo evitarlos)"},{"location":"04-funciones-procedimientos/#resumen","text":"Las subacciones encapsulan tareas y favorecen dise\u00f1o modular. Procedimientos : no devuelven valor; pueden producir efectos y modificar par\u00e1metros de salida. Funciones : devuelven un \u00fanico resultado y son \u00fatiles dentro de expresiones. Gestion\u00e1 correctamente nombres y par\u00e1metros (cantidad, orden, tipo) para llamadas seguras.","title":"Resumen"},{"location":"05-secuencias-datos/","text":"Secuencias de Datos Elementales Esta p\u00e1gina introduce el concepto de secuencias de datos elementales , sus caracter\u00edsticas, clasificaci\u00f3n y el pseudoc\u00f3digo est\u00e1ndar para su tratamiento (acciones predefinidas ARR , AVZ , CREAR , ESCRIBIR , CERRAR ). \u00bfQu\u00e9 es una Secuencia de Datos Elementales? Es un conjunto de datos relacionados que se almacena en memoria externa (disco, pendrive, etc.). La secuencia presenta orden y posee un primer y \u00faltimo elemento; adem\u00e1s, debe estar definido un indicador de fin de secuencia . Caracter\u00edsticas clave Primer elemento : desde \u00e9l se accede al resto por sucesi\u00f3n. Relaci\u00f3n de sucesi\u00f3n : cada elemento (salvo el \u00faltimo) precede a otro; cada elemento (salvo el primero) sucede a otro. \u00daltimo elemento : toda secuencia tiene un final bien definido. Fin de secuencia (FDS) : puede ser una marca (sentinela) o una cantidad conocida de elementos. Ejemplos de FDS Num\u00e9rica con marca: ... 1990 1994 1992 2000 1998 -1 (termina en -1 ). Caracteres con marca: A C 2 5 6 X E A F 3 2 5 B B % (termina en % ). Definida por cantidad: \"primeros 4 promedios del a\u00f1o\". Clasificaciones principales Por contenido Num\u00e9ricas (enteros, reales) De caracteres (c\u00f3digos, patentes, etc.) De registros (se ver\u00e1 en temas posteriores) Por cantidad de elementos Definidas : se conoce la cantidad (p. ej., 10 elementos). Indefinidas : no se conoce la cantidad; se usa marca o condici\u00f3n de fin. Por pureza Puras : todos los elementos pertenecen a la misma especie y el \u00faltimo se trata igual que los dem\u00e1s. Suelen manejarse con post-test . Impuras : incluyen un elemento extra\u00f1o (marca) que no se procesa; se manejan con pre-test . Pseudoc\u00f3digo: Acciones predefinidas Estas acciones aseguran el acceso secuencial correcto a los elementos. ARR(nombre_secuencia) \u2192 Arrancar el tratamiento de una secuencia existente. AVZ(nombre_secuencia, var) \u2192 Avanzar y recuperar el siguiente elemento en var . CREAR(nombre_secuencia_salida) \u2192 Inicializa una nueva secuencia vac\u00eda (solo para salida). ESCRIBIR(nombre_secuencia_salida, var) \u2192 Agrega var a la secuencia de salida creada. CERRAR(nombre_secuencia) \u2192 Finaliza el tratamiento de la secuencia (libera recursos / asegura persistencia). Declaraci\u00f3n t\u00edpica en el Ambiente ACCION Secu ES AMBIENTE sec: Secuencia de [tipo_dato] sal: Secuencia de [tipo_dato] v: [tipo_dato] PROCESO // ... FINACCION Esquemas de recorrido (patrones) Esquema N\u00ba1 \u2014 Pre-test (impura con marca) Cuenta elementos antes de tratar el FDS. ACCION esquema_1 ES AMBIENTE S: secuencia de caracter v: caracter cont: entero PROCESO ARR(S) cont := 0 AVZ(S, v) Mientras v <> '#' Hacer cont := cont + 1 AVZ(S, v) FinMientras ESC(\"Elementos en la secuencia = \", cont) FINACCION Esquema N\u00ba2 \u2014 Post-test (pura definida por marca final) Procesa incluyendo el \u00faltimo elemento v\u00e1lido y termina al ver la marca. ACCION esquema_2 ES AMBIENTE S: secuencia de entero v, cont: entero PROCESO ARR(S) cont := 0 Repetir AVZ(S, v) cont := cont + 1 Hasta que v = 999 ESCRIBIR(cont) FINACCION Esquema N\u00ba3 \u2014 Definida por cantidad (contador PARA ) Lee exactamente N elementos. ACCION esquema_3 ES AMBIENTE S: secuencia de entero v, i: entero PROCESO ARR(S) Para i := 1 Hasta 10 Hacer AVZ(S, v) ESC(v) FinPara FINACCION Ejemplos pr\u00e1cticos de tratamiento Copiar de una secuencia a otra (indefinida impura) ACCION CopiarSecuencia ES AMBIENTE ent: Secuencia de caracter sal: Secuencia de caracter x: caracter PROCESO ARR(ent) CREAR(sal) AVZ(ent, x) Mientras x <> '%' Hacer ESCRIBIR(sal, x) AVZ(ent, x) FinMientras CERRAR(sal) FINACCION Contar mayores que un umbral (definida por cantidad) ACCION ContarMayores ES AMBIENTE ent: Secuencia de entero i, v, umbral, cuenta: entero PROCESO ARR(ent) cuenta := 0 umbral := 100 Para i := 1 Hasta 20 Hacer AVZ(ent, v) Si v > umbral Entonces cuenta := cuenta + 1 FinSi FinPara ESC(\"Mayores a \", umbral, \": \", cuenta) FINACCION Buenas pr\u00e1cticas Eleg\u00ed pre-test si trabaj\u00e1s con marca (impura) y el elemento de fin no debe procesarse. Eleg\u00ed post-test en secuencias puras para asegurar al menos una lectura y tratar por igual el \u00faltimo. Declarar una variable de trabajo (buffer) para AVZ del mismo tipo que la secuencia. Record\u00e1 cerrar secuencias de salida ( CERRAR ) para garantizar persistencia. Resumen Las secuencias se recorren de forma secuencial con ARR y AVZ . El fin de secuencia es imprescindible (marca o cantidad). Us\u00e1 el esquema que corresponda: pre-test (impura), post-test (pura) o definida (contador). CREAR/ESCRIBIR/CERRAR habilitan la generaci\u00f3n de nuevas secuencias de salida.","title":"Secuencias de datos"},{"location":"05-secuencias-datos/#secuencias-de-datos-elementales","text":"Esta p\u00e1gina introduce el concepto de secuencias de datos elementales , sus caracter\u00edsticas, clasificaci\u00f3n y el pseudoc\u00f3digo est\u00e1ndar para su tratamiento (acciones predefinidas ARR , AVZ , CREAR , ESCRIBIR , CERRAR ).","title":"Secuencias de Datos Elementales"},{"location":"05-secuencias-datos/#que-es-una-secuencia-de-datos-elementales","text":"Es un conjunto de datos relacionados que se almacena en memoria externa (disco, pendrive, etc.). La secuencia presenta orden y posee un primer y \u00faltimo elemento; adem\u00e1s, debe estar definido un indicador de fin de secuencia .","title":"\u00bfQu\u00e9 es una Secuencia de Datos Elementales?"},{"location":"05-secuencias-datos/#caracteristicas-clave","text":"Primer elemento : desde \u00e9l se accede al resto por sucesi\u00f3n. Relaci\u00f3n de sucesi\u00f3n : cada elemento (salvo el \u00faltimo) precede a otro; cada elemento (salvo el primero) sucede a otro. \u00daltimo elemento : toda secuencia tiene un final bien definido. Fin de secuencia (FDS) : puede ser una marca (sentinela) o una cantidad conocida de elementos. Ejemplos de FDS Num\u00e9rica con marca: ... 1990 1994 1992 2000 1998 -1 (termina en -1 ). Caracteres con marca: A C 2 5 6 X E A F 3 2 5 B B % (termina en % ). Definida por cantidad: \"primeros 4 promedios del a\u00f1o\".","title":"Caracter\u00edsticas clave"},{"location":"05-secuencias-datos/#clasificaciones-principales","text":"","title":"Clasificaciones principales"},{"location":"05-secuencias-datos/#por-contenido","text":"Num\u00e9ricas (enteros, reales) De caracteres (c\u00f3digos, patentes, etc.) De registros (se ver\u00e1 en temas posteriores)","title":"Por contenido"},{"location":"05-secuencias-datos/#por-cantidad-de-elementos","text":"Definidas : se conoce la cantidad (p. ej., 10 elementos). Indefinidas : no se conoce la cantidad; se usa marca o condici\u00f3n de fin.","title":"Por cantidad de elementos"},{"location":"05-secuencias-datos/#por-pureza","text":"Puras : todos los elementos pertenecen a la misma especie y el \u00faltimo se trata igual que los dem\u00e1s. Suelen manejarse con post-test . Impuras : incluyen un elemento extra\u00f1o (marca) que no se procesa; se manejan con pre-test .","title":"Por pureza"},{"location":"05-secuencias-datos/#pseudocodigo-acciones-predefinidas","text":"Estas acciones aseguran el acceso secuencial correcto a los elementos. ARR(nombre_secuencia) \u2192 Arrancar el tratamiento de una secuencia existente. AVZ(nombre_secuencia, var) \u2192 Avanzar y recuperar el siguiente elemento en var . CREAR(nombre_secuencia_salida) \u2192 Inicializa una nueva secuencia vac\u00eda (solo para salida). ESCRIBIR(nombre_secuencia_salida, var) \u2192 Agrega var a la secuencia de salida creada. CERRAR(nombre_secuencia) \u2192 Finaliza el tratamiento de la secuencia (libera recursos / asegura persistencia).","title":"Pseudoc\u00f3digo: Acciones predefinidas"},{"location":"05-secuencias-datos/#declaracion-tipica-en-el-ambiente","text":"ACCION Secu ES AMBIENTE sec: Secuencia de [tipo_dato] sal: Secuencia de [tipo_dato] v: [tipo_dato] PROCESO // ... FINACCION","title":"Declaraci\u00f3n t\u00edpica en el Ambiente"},{"location":"05-secuencias-datos/#esquemas-de-recorrido-patrones","text":"","title":"Esquemas de recorrido (patrones)"},{"location":"05-secuencias-datos/#esquema-no1-pre-test-impura-con-marca","text":"Cuenta elementos antes de tratar el FDS. ACCION esquema_1 ES AMBIENTE S: secuencia de caracter v: caracter cont: entero PROCESO ARR(S) cont := 0 AVZ(S, v) Mientras v <> '#' Hacer cont := cont + 1 AVZ(S, v) FinMientras ESC(\"Elementos en la secuencia = \", cont) FINACCION","title":"Esquema N\u00ba1 \u2014 Pre-test (impura con marca)"},{"location":"05-secuencias-datos/#esquema-no2-post-test-pura-definida-por-marca-final","text":"Procesa incluyendo el \u00faltimo elemento v\u00e1lido y termina al ver la marca. ACCION esquema_2 ES AMBIENTE S: secuencia de entero v, cont: entero PROCESO ARR(S) cont := 0 Repetir AVZ(S, v) cont := cont + 1 Hasta que v = 999 ESCRIBIR(cont) FINACCION","title":"Esquema N\u00ba2 \u2014 Post-test (pura definida por marca final)"},{"location":"05-secuencias-datos/#esquema-no3-definida-por-cantidad-contador-para","text":"Lee exactamente N elementos. ACCION esquema_3 ES AMBIENTE S: secuencia de entero v, i: entero PROCESO ARR(S) Para i := 1 Hasta 10 Hacer AVZ(S, v) ESC(v) FinPara FINACCION","title":"Esquema N\u00ba3 \u2014 Definida por cantidad (contador PARA)"},{"location":"05-secuencias-datos/#ejemplos-practicos-de-tratamiento","text":"","title":"Ejemplos pr\u00e1cticos de tratamiento"},{"location":"05-secuencias-datos/#copiar-de-una-secuencia-a-otra-indefinida-impura","text":"ACCION CopiarSecuencia ES AMBIENTE ent: Secuencia de caracter sal: Secuencia de caracter x: caracter PROCESO ARR(ent) CREAR(sal) AVZ(ent, x) Mientras x <> '%' Hacer ESCRIBIR(sal, x) AVZ(ent, x) FinMientras CERRAR(sal) FINACCION","title":"Copiar de una secuencia a otra (indefinida impura)"},{"location":"05-secuencias-datos/#contar-mayores-que-un-umbral-definida-por-cantidad","text":"ACCION ContarMayores ES AMBIENTE ent: Secuencia de entero i, v, umbral, cuenta: entero PROCESO ARR(ent) cuenta := 0 umbral := 100 Para i := 1 Hasta 20 Hacer AVZ(ent, v) Si v > umbral Entonces cuenta := cuenta + 1 FinSi FinPara ESC(\"Mayores a \", umbral, \": \", cuenta) FINACCION","title":"Contar mayores que un umbral (definida por cantidad)"},{"location":"05-secuencias-datos/#buenas-practicas","text":"Eleg\u00ed pre-test si trabaj\u00e1s con marca (impura) y el elemento de fin no debe procesarse. Eleg\u00ed post-test en secuencias puras para asegurar al menos una lectura y tratar por igual el \u00faltimo. Declarar una variable de trabajo (buffer) para AVZ del mismo tipo que la secuencia. Record\u00e1 cerrar secuencias de salida ( CERRAR ) para garantizar persistencia.","title":"Buenas pr\u00e1cticas"},{"location":"05-secuencias-datos/#resumen","text":"Las secuencias se recorren de forma secuencial con ARR y AVZ . El fin de secuencia es imprescindible (marca o cantidad). Us\u00e1 el esquema que corresponda: pre-test (impura), post-test (pura) o definida (contador). CREAR/ESCRIBIR/CERRAR habilitan la generaci\u00f3n de nuevas secuencias de salida.","title":"Resumen"},{"location":"06-subsecuencias/","text":"Subsecuencias En esta p\u00e1gina se presentan los fundamentos de subsecuencias dentro de secuencias de datos elementales , su clasificaci\u00f3n ( enlazadas y jer\u00e1rquicas ), criterios de inicio/fin y patrones de tratamiento con pseudoc\u00f3digo. Ideas clave Una secuencia es un conjunto homog\u00e9neo y ordenado de elementos. Una subsecuencia es un conjunto de elementos consecutivos dentro de una secuencia principal, definido por reglas de inicio y fin . Las subsecuencias heredan las propiedades de la secuencia de la que forman parte (orden, fin, homogeneidad del tipo de dato, etc.). Definiciones frecuentes Subsecuencia PALABRA Subconjunto de elementos consecutivos de una secuencia de caracteres que: empieza en un car\u00e1cter distinto de espacio ( ' ' ), y termina en un espacio o en una marca definida por el problema (p. ej., final de palabra, fin de secuencia, etc.). Subsecuencia ORACI\u00d3N Subconjunto de elementos consecutivos de una secuencia de caracteres que: empieza en un car\u00e1cter distinto de espacio ( ' ' ), y termina en un delimitador final de oraci\u00f3n (p. ej., '.' ) u otra marca especificada. Palabra con contenido : cadena de caracteres no blancos que finaliza en '.' o en blanco . Palabra vac\u00eda : cadena de blancos consecutivos que finaliza en un car\u00e1cter no blanco . Tipos de relaci\u00f3n entre subsecuencias 1) Subsecuencias enlazadas Las subsecuencias se encadenan una detr\u00e1s de otra. Al terminar una subsecuencia, comienza la siguiente. Ejemplo cl\u00e1sico: secuencia de caracteres que almacena c\u00f3digos de 4 d\u00edgitos en serie ( 1 3 2 5 4 8 9 0 ... ). Cada bloque de 4 conforma una subsecuencia . 2) Subsecuencias jer\u00e1rquicas Las subsecuencias se incluyen unas en otras por niveles . No hay continuidad obligatoria entre subsecuencias del mismo nivel. Ejemplo cl\u00e1sico: Texto \u2192 P\u00e1rrafos \u2192 Oraciones \u2192 Palabras . Patrones de tratamiento A continuaci\u00f3n se muestran esquemas de recorrido reutilizables. Se asume el conjunto de acciones para secuencias: ARR , AVZ , CREAR , ESCRIBIR , CERRAR . Convenci\u00f3n : S es una secuencia de caracteres y c una variable car\u00e1cter . A. Palabras en texto (pre-test sobre blancos) Ignora palabras vac\u00edas (m\u00faltiples espacios). Cuenta palabras con contenido . ACCION ContarPalabras ES AMBIENTE S: Secuencia de caracter c: caracter en_palabra: logico total: entero PROCESO ARR(S) AVZ(S, c) en_palabra := F total := 0 Mientras c <> '#' Hacer // '#' = fin de secuencia (ejemplo de marca) Si c <> ' ' y no en_palabra Entonces en_palabra := V // inicia palabra con contenido total := total + 1 FinSi Si c = ' ' y en_palabra Entonces en_palabra := F // cerr\u00f3 la palabra al ver blanco FinSi AVZ(S, c) FinMientras ESC(\"Palabras con contenido:\", total) FINACCION B. Longitud m\u00e1xima de palabra Registra la longitud de la palabra m\u00e1s larga . ACCION LongitudMaxPalabra ES AMBIENTE S: Secuencia de caracter c: caracter en_palabra: logico long_act, long_max: entero PROCESO ARR(S) AVZ(S, c) en_palabra := F long_act := 0 long_max := 0 Mientras c <> '#' Hacer Si c <> ' ' Entonces Si no en_palabra Entonces en_palabra := V long_act := 0 FinSi long_act := long_act + 1 Contrario Si en_palabra Entonces en_palabra := F Si long_act > long_max Entonces long_max := long_act FinSi FinSi FinSi AVZ(S, c) FinMientras // cierre si termin\u00f3 sin blanco final Si en_palabra y long_act > long_max Entonces long_max := long_act FinSi ESC(\"Longitud m\u00e1xima:\", long_max) FINACCION C. Oraciones en texto (delimitador '.') Cuenta cu\u00e1ntas oraciones hay en el texto. ACCION ContarOraciones ES AMBIENTE S: Secuencia de caracter c: caracter en_contenido: logico oraciones: entero PROCESO ARR(S) AVZ(S, c) en_contenido := F oraciones := 0 Mientras c <> '#' Hacer Si c <> ' ' y c <> '.' Entonces en_contenido := V FinSi Si c = '.' y en_contenido Entonces oraciones := oraciones + 1 // cierre de oraci\u00f3n con contenido en_contenido := F FinSi AVZ(S, c) FinMientras ESC(\"Cantidad de oraciones:\", oraciones) FINACCION Subsecuencias enlazadas (bloques de tama\u00f1o fijo) D. Contar d\u00edgitos '0' en c\u00f3digos de 4 caracteres Suponga S contiene c\u00f3digos de 4 caracteres consecutivos; por cada bloque (subsecuencia) contar los ceros y acumular total general. ACCION CerosEnCodigos4 ES AMBIENTE S: Secuencia de caracter c: caracter i, ceros_cod, ceros_total: entero PROCESO ARR(S) ceros_total := 0 Repetir ceros_cod := 0 Para i := 1 Hasta 4 Hacer AVZ(S, c) Si c = '#' Entonces // marca: fin de secuencia // fin abrupto: salir de la rutina ESC(\"Total ceros:\", ceros_total) regresar FinSi Si c = '0' Entonces ceros_cod := ceros_cod + 1 FinSi FinPara // tratar el bloque completo ESC(\"Ceros en c\u00f3digo:\", ceros_cod) ceros_total := ceros_total + ceros_cod Hasta que falso // contin\u00faa hasta ver '#' FINACCION Si prefer\u00eds un fin controlado , reemplaz\u00e1 la condici\u00f3n de corte por lectura anticipada del primer car\u00e1cter del bloque y verific\u00e1 '#' antes de entrar al Para . Subsecuencias jer\u00e1rquicas (anidadas) E. Texto \u2192 Oraciones \u2192 Palabras: promedio de longitud de palabra por oraci\u00f3n Calcula, por cada oraci\u00f3n , el promedio de longitudes de sus palabras con contenido ; al final emite el promedio global . ACCION PromedioLongitudesPorOracion ES AMBIENTE S: Secuencia de caracter c: caracter // nivel palabra en_pal: logico long_pal: entero // nivel oraci\u00f3n suma_long, cant_pal, cant_orac: entero prom_orac, prom_global: real PROCESO ARR(S) AVZ(S, c) // inicializaciones en_pal := F long_pal := 0 suma_long := 0 cant_pal := 0 cant_orac := 0 Mientras c <> '#' Hacer // recorre texto completo // nivel palabra Si c <> ' ' y c <> '.' Entonces Si no en_pal Entonces en_pal := V long_pal := 0 FinSi long_pal := long_pal + 1 Contrario // cerr\u00f3 palabra por espacio o punto Si en_pal Entonces en_pal := F cant_pal := cant_pal + 1 suma_long := suma_long + long_pal FinSi // si es punto, cierra oraci\u00f3n Si c = '.' Entonces cant_orac := cant_orac + 1 Si cant_pal > 0 Entonces prom_orac := suma_long / cant_pal ESC(\"Promedio en oraci\u00f3n \", cant_orac, \": \", prom_orac) Contrario ESC(\"Oraci\u00f3n \", cant_orac, \" sin palabras\" ) FinSi // reset para nueva oraci\u00f3n suma_long := 0 cant_pal := 0 FinSi FinSi AVZ(S, c) FinMientras // cierre por fin sin punto final Si en_pal Entonces cant_pal := cant_pal + 1 suma_long := suma_long + long_pal FinSi Si cant_pal > 0 Entonces cant_orac := cant_orac + 1 prom_orac := suma_long / cant_pal ESC(\"Promedio en oraci\u00f3n \", cant_orac, \": \", prom_orac) FinSi // promedio global (si se requiere) // (podr\u00eda promediar los promedios por oraci\u00f3n o sobre todas las palabras del texto) FINACCION Buenas pr\u00e1cticas y chequeos Defin\u00ed claramente los delimitadores de inicio y fin (espacio, punto, marca '#' , tama\u00f1o fijo, etc.). Normaliz\u00e1 casos de borde : m\u00faltiples espacios, texto que no termina en delimitador, secuencias vac\u00edas. En encadenadas de tama\u00f1o fijo, valid\u00e1 longitud (evit\u00e1 bloques incompletos). Manten\u00e9 estado m\u00ednimo : banderas en_palabra / en_contenido , contadores y acumuladores. Document\u00e1 la pol\u00edtica de conteo : \u00bfse cuentan palabras vac\u00edas? \u00bfqui\u00e9n cierra la \u00faltima palabra si no hay blanco final? Resumen Las subsecuencias modelan segmentos consecutivos dentro de una secuencia. Enlazadas : bloques consecutivos (p. ej., c\u00f3digos de 4). Jer\u00e1rquicas : niveles (texto\u2192oraci\u00f3n\u2192palabra). Los patrones propuestos cubren conteo de palabras, longitudes, oraciones y tratamiento por bloques. El \u00e9xito del algoritmo depende de definir bien los delimitadores y normalizar casos de borde .","title":"Subsecuencias"},{"location":"06-subsecuencias/#subsecuencias","text":"En esta p\u00e1gina se presentan los fundamentos de subsecuencias dentro de secuencias de datos elementales , su clasificaci\u00f3n ( enlazadas y jer\u00e1rquicas ), criterios de inicio/fin y patrones de tratamiento con pseudoc\u00f3digo.","title":"Subsecuencias"},{"location":"06-subsecuencias/#ideas-clave","text":"Una secuencia es un conjunto homog\u00e9neo y ordenado de elementos. Una subsecuencia es un conjunto de elementos consecutivos dentro de una secuencia principal, definido por reglas de inicio y fin . Las subsecuencias heredan las propiedades de la secuencia de la que forman parte (orden, fin, homogeneidad del tipo de dato, etc.).","title":"Ideas clave"},{"location":"06-subsecuencias/#definiciones-frecuentes","text":"","title":"Definiciones frecuentes"},{"location":"06-subsecuencias/#subsecuencia-palabra","text":"Subconjunto de elementos consecutivos de una secuencia de caracteres que: empieza en un car\u00e1cter distinto de espacio ( ' ' ), y termina en un espacio o en una marca definida por el problema (p. ej., final de palabra, fin de secuencia, etc.).","title":"Subsecuencia PALABRA"},{"location":"06-subsecuencias/#subsecuencia-oracion","text":"Subconjunto de elementos consecutivos de una secuencia de caracteres que: empieza en un car\u00e1cter distinto de espacio ( ' ' ), y termina en un delimitador final de oraci\u00f3n (p. ej., '.' ) u otra marca especificada. Palabra con contenido : cadena de caracteres no blancos que finaliza en '.' o en blanco . Palabra vac\u00eda : cadena de blancos consecutivos que finaliza en un car\u00e1cter no blanco .","title":"Subsecuencia ORACI\u00d3N"},{"location":"06-subsecuencias/#tipos-de-relacion-entre-subsecuencias","text":"","title":"Tipos de relaci\u00f3n entre subsecuencias"},{"location":"06-subsecuencias/#1-subsecuencias-enlazadas","text":"Las subsecuencias se encadenan una detr\u00e1s de otra. Al terminar una subsecuencia, comienza la siguiente. Ejemplo cl\u00e1sico: secuencia de caracteres que almacena c\u00f3digos de 4 d\u00edgitos en serie ( 1 3 2 5 4 8 9 0 ... ). Cada bloque de 4 conforma una subsecuencia .","title":"1) Subsecuencias enlazadas"},{"location":"06-subsecuencias/#2-subsecuencias-jerarquicas","text":"Las subsecuencias se incluyen unas en otras por niveles . No hay continuidad obligatoria entre subsecuencias del mismo nivel. Ejemplo cl\u00e1sico: Texto \u2192 P\u00e1rrafos \u2192 Oraciones \u2192 Palabras .","title":"2) Subsecuencias jer\u00e1rquicas"},{"location":"06-subsecuencias/#patrones-de-tratamiento","text":"A continuaci\u00f3n se muestran esquemas de recorrido reutilizables. Se asume el conjunto de acciones para secuencias: ARR , AVZ , CREAR , ESCRIBIR , CERRAR . Convenci\u00f3n : S es una secuencia de caracteres y c una variable car\u00e1cter .","title":"Patrones de tratamiento"},{"location":"06-subsecuencias/#a-palabras-en-texto-pre-test-sobre-blancos","text":"Ignora palabras vac\u00edas (m\u00faltiples espacios). Cuenta palabras con contenido . ACCION ContarPalabras ES AMBIENTE S: Secuencia de caracter c: caracter en_palabra: logico total: entero PROCESO ARR(S) AVZ(S, c) en_palabra := F total := 0 Mientras c <> '#' Hacer // '#' = fin de secuencia (ejemplo de marca) Si c <> ' ' y no en_palabra Entonces en_palabra := V // inicia palabra con contenido total := total + 1 FinSi Si c = ' ' y en_palabra Entonces en_palabra := F // cerr\u00f3 la palabra al ver blanco FinSi AVZ(S, c) FinMientras ESC(\"Palabras con contenido:\", total) FINACCION","title":"A. Palabras en texto (pre-test sobre blancos)"},{"location":"06-subsecuencias/#b-longitud-maxima-de-palabra","text":"Registra la longitud de la palabra m\u00e1s larga . ACCION LongitudMaxPalabra ES AMBIENTE S: Secuencia de caracter c: caracter en_palabra: logico long_act, long_max: entero PROCESO ARR(S) AVZ(S, c) en_palabra := F long_act := 0 long_max := 0 Mientras c <> '#' Hacer Si c <> ' ' Entonces Si no en_palabra Entonces en_palabra := V long_act := 0 FinSi long_act := long_act + 1 Contrario Si en_palabra Entonces en_palabra := F Si long_act > long_max Entonces long_max := long_act FinSi FinSi FinSi AVZ(S, c) FinMientras // cierre si termin\u00f3 sin blanco final Si en_palabra y long_act > long_max Entonces long_max := long_act FinSi ESC(\"Longitud m\u00e1xima:\", long_max) FINACCION","title":"B. Longitud m\u00e1xima de palabra"},{"location":"06-subsecuencias/#c-oraciones-en-texto-delimitador","text":"Cuenta cu\u00e1ntas oraciones hay en el texto. ACCION ContarOraciones ES AMBIENTE S: Secuencia de caracter c: caracter en_contenido: logico oraciones: entero PROCESO ARR(S) AVZ(S, c) en_contenido := F oraciones := 0 Mientras c <> '#' Hacer Si c <> ' ' y c <> '.' Entonces en_contenido := V FinSi Si c = '.' y en_contenido Entonces oraciones := oraciones + 1 // cierre de oraci\u00f3n con contenido en_contenido := F FinSi AVZ(S, c) FinMientras ESC(\"Cantidad de oraciones:\", oraciones) FINACCION","title":"C. Oraciones en texto (delimitador '.')"},{"location":"06-subsecuencias/#subsecuencias-enlazadas-bloques-de-tamano-fijo","text":"","title":"Subsecuencias enlazadas (bloques de tama\u00f1o fijo)"},{"location":"06-subsecuencias/#d-contar-digitos-0-en-codigos-de-4-caracteres","text":"Suponga S contiene c\u00f3digos de 4 caracteres consecutivos; por cada bloque (subsecuencia) contar los ceros y acumular total general. ACCION CerosEnCodigos4 ES AMBIENTE S: Secuencia de caracter c: caracter i, ceros_cod, ceros_total: entero PROCESO ARR(S) ceros_total := 0 Repetir ceros_cod := 0 Para i := 1 Hasta 4 Hacer AVZ(S, c) Si c = '#' Entonces // marca: fin de secuencia // fin abrupto: salir de la rutina ESC(\"Total ceros:\", ceros_total) regresar FinSi Si c = '0' Entonces ceros_cod := ceros_cod + 1 FinSi FinPara // tratar el bloque completo ESC(\"Ceros en c\u00f3digo:\", ceros_cod) ceros_total := ceros_total + ceros_cod Hasta que falso // contin\u00faa hasta ver '#' FINACCION Si prefer\u00eds un fin controlado , reemplaz\u00e1 la condici\u00f3n de corte por lectura anticipada del primer car\u00e1cter del bloque y verific\u00e1 '#' antes de entrar al Para .","title":"D. Contar d\u00edgitos '0' en c\u00f3digos de 4 caracteres"},{"location":"06-subsecuencias/#subsecuencias-jerarquicas-anidadas","text":"","title":"Subsecuencias jer\u00e1rquicas (anidadas)"},{"location":"06-subsecuencias/#e-texto-oraciones-palabras-promedio-de-longitud-de-palabra-por-oracion","text":"Calcula, por cada oraci\u00f3n , el promedio de longitudes de sus palabras con contenido ; al final emite el promedio global . ACCION PromedioLongitudesPorOracion ES AMBIENTE S: Secuencia de caracter c: caracter // nivel palabra en_pal: logico long_pal: entero // nivel oraci\u00f3n suma_long, cant_pal, cant_orac: entero prom_orac, prom_global: real PROCESO ARR(S) AVZ(S, c) // inicializaciones en_pal := F long_pal := 0 suma_long := 0 cant_pal := 0 cant_orac := 0 Mientras c <> '#' Hacer // recorre texto completo // nivel palabra Si c <> ' ' y c <> '.' Entonces Si no en_pal Entonces en_pal := V long_pal := 0 FinSi long_pal := long_pal + 1 Contrario // cerr\u00f3 palabra por espacio o punto Si en_pal Entonces en_pal := F cant_pal := cant_pal + 1 suma_long := suma_long + long_pal FinSi // si es punto, cierra oraci\u00f3n Si c = '.' Entonces cant_orac := cant_orac + 1 Si cant_pal > 0 Entonces prom_orac := suma_long / cant_pal ESC(\"Promedio en oraci\u00f3n \", cant_orac, \": \", prom_orac) Contrario ESC(\"Oraci\u00f3n \", cant_orac, \" sin palabras\" ) FinSi // reset para nueva oraci\u00f3n suma_long := 0 cant_pal := 0 FinSi FinSi AVZ(S, c) FinMientras // cierre por fin sin punto final Si en_pal Entonces cant_pal := cant_pal + 1 suma_long := suma_long + long_pal FinSi Si cant_pal > 0 Entonces cant_orac := cant_orac + 1 prom_orac := suma_long / cant_pal ESC(\"Promedio en oraci\u00f3n \", cant_orac, \": \", prom_orac) FinSi // promedio global (si se requiere) // (podr\u00eda promediar los promedios por oraci\u00f3n o sobre todas las palabras del texto) FINACCION","title":"E. Texto \u2192 Oraciones \u2192 Palabras: promedio de longitud de palabra por oraci\u00f3n"},{"location":"06-subsecuencias/#buenas-practicas-y-chequeos","text":"Defin\u00ed claramente los delimitadores de inicio y fin (espacio, punto, marca '#' , tama\u00f1o fijo, etc.). Normaliz\u00e1 casos de borde : m\u00faltiples espacios, texto que no termina en delimitador, secuencias vac\u00edas. En encadenadas de tama\u00f1o fijo, valid\u00e1 longitud (evit\u00e1 bloques incompletos). Manten\u00e9 estado m\u00ednimo : banderas en_palabra / en_contenido , contadores y acumuladores. Document\u00e1 la pol\u00edtica de conteo : \u00bfse cuentan palabras vac\u00edas? \u00bfqui\u00e9n cierra la \u00faltima palabra si no hay blanco final?","title":"Buenas pr\u00e1cticas y chequeos"},{"location":"06-subsecuencias/#resumen","text":"Las subsecuencias modelan segmentos consecutivos dentro de una secuencia. Enlazadas : bloques consecutivos (p. ej., c\u00f3digos de 4). Jer\u00e1rquicas : niveles (texto\u2192oraci\u00f3n\u2192palabra). Los patrones propuestos cubren conteo de palabras, longitudes, oraciones y tratamiento por bloques. El \u00e9xito del algoritmo depende de definir bien los delimitadores y normalizar casos de borde .","title":"Resumen"},{"location":"07-registros/","text":"Registros En esta p\u00e1gina se introducen los registros como tipo de dato estructurado: su motivaci\u00f3n, definici\u00f3n, componentes, clasificaci\u00f3n de campos (contenido/continente), campos clave (primaria/for\u00e1nea/secundaria), sintaxis en pseudoc\u00f3digo y ejemplos pr\u00e1cticos. El foco est\u00e1 en el almacenamiento en memoria interna y el tratamiento como unidad l\u00f3gica . Visi\u00f3n general Un registro es un tipo de dato estructurado y est\u00e1tico compuesto por campos que pueden ser de diferentes tipos (heterog\u00e9neo). Se utiliza para representar entidades del mundo real (por ejemplo, estudiante , producto , medicamento ). Ideas clave Estructura heterog\u00e9nea : cada campo puede ser entero, real, car\u00e1cter/alfanum\u00e9rico, l\u00f3gico u otro registro . Memoria interna : los registros viven en RAM mientras el algoritmo los procesa. Unidad de tratamiento : aunque tenga varios campos, el registro se considera una sola entidad ; se accede a sus partes con el selector de campo . Anatom\u00eda de un registro Un campo se define por: Nombre (identificador \u00fanico dentro del registro) Tipo (entero, real, alfanum\u00e9rico, l\u00f3gico, u otra estructura) Tama\u00f1o (si aplica, p. ej., AN(30), N(8), etc.) Selector de campo Se utiliza para especificar a qu\u00e9 campo se accede dentro del registro. En pseudoc\u00f3digo lo representaremos con el punto ( . ): reg.campo . Tipos de campos Campos contenido : almacenan un \u00fanico dato simple (p. ej., edad: entero ). Campos continente : est\u00e1n compuestos por otros campos (p. ej., fecha con d\u00eda/mes/a\u00f1o ; telefono con caracter\u00edstica/n\u00famero ). Un campo continente puede anidarse: persona.domicilio.ciudad . Campos clave Un campo clave identifica un registro de manera \u00fanica dentro de un conjunto. Por formato Clave simple : formada por un solo campo contenido (p. ej., dni ). Clave compleja : formada por varios campos (usualmente continentales) p. ej., fecha_vacunaci\u00f3n = (d\u00eda, mes, a\u00f1o) . Por funci\u00f3n Clave primaria : identifica \u00fanicamente el registro (no se repite). Clave for\u00e1nea : referencia la clave primaria de otro conjunto de registros (relaci\u00f3n entre entidades). Clave secundaria : alternativa de acceso/ordenaci\u00f3n que no garantiza unicidad. Sintaxis (pseudoc\u00f3digo) Definici\u00f3n de tipo registro y variables // Definici\u00f3n del tipo ESTUDIANTE = Registro dni: N(8) apellido: AN(30) nombre: AN(30) carrera: {ISI, IEM, IQ, LAR} // ejemplo de tipo enumerado ingreso: N(4) // a\u00f1o de ingreso FinRegistro // Variable de tipo registro alumno: ESTUDIANTE Acceso a campos (selector) alumno.dni := 45236555 alumno.apellido := \"PEREZ\" alumno.nombre := \"JUAN\" alumno.carrera := ISI alumno.ingreso := 2023 Campos continente (anidaci\u00f3n) FECHA = Registro dia: 1..31 mes: 1..12 anio: 1900..2100 FinRegistro VACUNA = Registro codigo: AN(13) abreviatura: AN(4) fecha_aplicacion: FECHA // campo continente FinRegistro v: VACUNA v.fecha_aplicacion.dia := 23 v.fecha_aplicacion.mes := 4 v.fecha_aplicacion.anio := 2021 Patrones de uso 1) Carga de un registro (entrada de datos) ACCION CargarEstudiante ES AMBIENTE est: ESTUDIANTE PROCESO Esc(\"DNI:\") ; Leer(est.dni) Esc(\"Apellido:\") ; Leer(est.apellido) Esc(\"Nombre:\") ; Leer(est.nombre) Esc(\"Carrera:\") ; Leer(est.carrera) Esc(\"A\u00f1o ingreso:\") ; Leer(est.ingreso) // A partir de aqu\u00ed, 'est' est\u00e1 completo y listo para ser usado FINACCION 2) Emisi\u00f3n (salida formateada) SUBACCION ImprimirEstudiante(e: ESTUDIANTE) ES Esc(\"[\", e.dni, \"] \", e.apellido, \", \", e.nombre, \" - \", e.carrera, \" (\", e.ingreso, \")\") FINSUBACCION 3) Actualizaci\u00f3n de campos SUBACCION ActualizarIngreso(e: ESTUDIANTE; nuevo: N(4)) ES e.ingreso := nuevo FINSUBACCION 4) Comparaci\u00f3n por clave primaria FUNCION MismaPersona(a, b: ESTUDIANTE): logico devolver (a.dni = b.dni) FINFUNCION En colecciones (listas, tablas, archivos), us\u00e1 la clave primaria para b\u00fasquedas y detecci\u00f3n de duplicados. Buenas pr\u00e1cticas Defin\u00ed primero el tipo de registro en el Ambiente y luego declar\u00e1s variables de ese tipo. Manten\u00e9 nombres claros de campos y respet\u00e1 dominios (rangos/enums) para validar consistencia. Consider\u00e1 clave primaria desde el dise\u00f1o: \u00bfqu\u00e9 campo(s) identifican sin ambig\u00fcedad? Trat\u00e1 el registro como unidad : encapsul\u00e1 emisiones, cargas y validaciones en subacciones. Para campos continentales , prefer\u00ed tipos expl\u00edcitos (como FECHA ) en vez de tres enteros sueltos. Errores frecuentes Omitir asignaci\u00f3n de subcampos en campos continentales (p. ej., setear fecha sin d\u00eda/mes/a\u00f1o ). Duplicados por ausencia de verificaci\u00f3n de clave primaria . Inconsistencias de dominio (p. ej., mes = 16 ) por no validar rangos. Resumen Un registro modela una entidad con varios campos (posiblemente anidados). Se accede a los campos con un selector ( reg.campo ). Los campos clave son esenciales para identificaci\u00f3n (primaria), relaciones (for\u00e1nea) y acceso (secundaria). Dise\u00f1ar tipos claros y validar dominios mejora la consistencia y facilita su posterior uso en archivos y procesos .","title":"Registros"},{"location":"07-registros/#registros","text":"En esta p\u00e1gina se introducen los registros como tipo de dato estructurado: su motivaci\u00f3n, definici\u00f3n, componentes, clasificaci\u00f3n de campos (contenido/continente), campos clave (primaria/for\u00e1nea/secundaria), sintaxis en pseudoc\u00f3digo y ejemplos pr\u00e1cticos. El foco est\u00e1 en el almacenamiento en memoria interna y el tratamiento como unidad l\u00f3gica .","title":"Registros"},{"location":"07-registros/#vision-general","text":"Un registro es un tipo de dato estructurado y est\u00e1tico compuesto por campos que pueden ser de diferentes tipos (heterog\u00e9neo). Se utiliza para representar entidades del mundo real (por ejemplo, estudiante , producto , medicamento ). Ideas clave Estructura heterog\u00e9nea : cada campo puede ser entero, real, car\u00e1cter/alfanum\u00e9rico, l\u00f3gico u otro registro . Memoria interna : los registros viven en RAM mientras el algoritmo los procesa. Unidad de tratamiento : aunque tenga varios campos, el registro se considera una sola entidad ; se accede a sus partes con el selector de campo .","title":"Visi\u00f3n general"},{"location":"07-registros/#anatomia-de-un-registro","text":"Un campo se define por: Nombre (identificador \u00fanico dentro del registro) Tipo (entero, real, alfanum\u00e9rico, l\u00f3gico, u otra estructura) Tama\u00f1o (si aplica, p. ej., AN(30), N(8), etc.)","title":"Anatom\u00eda de un registro"},{"location":"07-registros/#selector-de-campo","text":"Se utiliza para especificar a qu\u00e9 campo se accede dentro del registro. En pseudoc\u00f3digo lo representaremos con el punto ( . ): reg.campo .","title":"Selector de campo"},{"location":"07-registros/#tipos-de-campos","text":"Campos contenido : almacenan un \u00fanico dato simple (p. ej., edad: entero ). Campos continente : est\u00e1n compuestos por otros campos (p. ej., fecha con d\u00eda/mes/a\u00f1o ; telefono con caracter\u00edstica/n\u00famero ). Un campo continente puede anidarse: persona.domicilio.ciudad .","title":"Tipos de campos"},{"location":"07-registros/#campos-clave","text":"Un campo clave identifica un registro de manera \u00fanica dentro de un conjunto.","title":"Campos clave"},{"location":"07-registros/#por-formato","text":"Clave simple : formada por un solo campo contenido (p. ej., dni ). Clave compleja : formada por varios campos (usualmente continentales) p. ej., fecha_vacunaci\u00f3n = (d\u00eda, mes, a\u00f1o) .","title":"Por formato"},{"location":"07-registros/#por-funcion","text":"Clave primaria : identifica \u00fanicamente el registro (no se repite). Clave for\u00e1nea : referencia la clave primaria de otro conjunto de registros (relaci\u00f3n entre entidades). Clave secundaria : alternativa de acceso/ordenaci\u00f3n que no garantiza unicidad.","title":"Por funci\u00f3n"},{"location":"07-registros/#sintaxis-pseudocodigo","text":"","title":"Sintaxis (pseudoc\u00f3digo)"},{"location":"07-registros/#definicion-de-tipo-registro-y-variables","text":"// Definici\u00f3n del tipo ESTUDIANTE = Registro dni: N(8) apellido: AN(30) nombre: AN(30) carrera: {ISI, IEM, IQ, LAR} // ejemplo de tipo enumerado ingreso: N(4) // a\u00f1o de ingreso FinRegistro // Variable de tipo registro alumno: ESTUDIANTE","title":"Definici\u00f3n de tipo registro y variables"},{"location":"07-registros/#acceso-a-campos-selector","text":"alumno.dni := 45236555 alumno.apellido := \"PEREZ\" alumno.nombre := \"JUAN\" alumno.carrera := ISI alumno.ingreso := 2023","title":"Acceso a campos (selector)"},{"location":"07-registros/#campos-continente-anidacion","text":"FECHA = Registro dia: 1..31 mes: 1..12 anio: 1900..2100 FinRegistro VACUNA = Registro codigo: AN(13) abreviatura: AN(4) fecha_aplicacion: FECHA // campo continente FinRegistro v: VACUNA v.fecha_aplicacion.dia := 23 v.fecha_aplicacion.mes := 4 v.fecha_aplicacion.anio := 2021","title":"Campos continente (anidaci\u00f3n)"},{"location":"07-registros/#patrones-de-uso","text":"","title":"Patrones de uso"},{"location":"07-registros/#1-carga-de-un-registro-entrada-de-datos","text":"ACCION CargarEstudiante ES AMBIENTE est: ESTUDIANTE PROCESO Esc(\"DNI:\") ; Leer(est.dni) Esc(\"Apellido:\") ; Leer(est.apellido) Esc(\"Nombre:\") ; Leer(est.nombre) Esc(\"Carrera:\") ; Leer(est.carrera) Esc(\"A\u00f1o ingreso:\") ; Leer(est.ingreso) // A partir de aqu\u00ed, 'est' est\u00e1 completo y listo para ser usado FINACCION","title":"1) Carga de un registro (entrada de datos)"},{"location":"07-registros/#2-emision-salida-formateada","text":"SUBACCION ImprimirEstudiante(e: ESTUDIANTE) ES Esc(\"[\", e.dni, \"] \", e.apellido, \", \", e.nombre, \" - \", e.carrera, \" (\", e.ingreso, \")\") FINSUBACCION","title":"2) Emisi\u00f3n (salida formateada)"},{"location":"07-registros/#3-actualizacion-de-campos","text":"SUBACCION ActualizarIngreso(e: ESTUDIANTE; nuevo: N(4)) ES e.ingreso := nuevo FINSUBACCION","title":"3) Actualizaci\u00f3n de campos"},{"location":"07-registros/#4-comparacion-por-clave-primaria","text":"FUNCION MismaPersona(a, b: ESTUDIANTE): logico devolver (a.dni = b.dni) FINFUNCION En colecciones (listas, tablas, archivos), us\u00e1 la clave primaria para b\u00fasquedas y detecci\u00f3n de duplicados.","title":"4) Comparaci\u00f3n por clave primaria"},{"location":"07-registros/#buenas-practicas","text":"Defin\u00ed primero el tipo de registro en el Ambiente y luego declar\u00e1s variables de ese tipo. Manten\u00e9 nombres claros de campos y respet\u00e1 dominios (rangos/enums) para validar consistencia. Consider\u00e1 clave primaria desde el dise\u00f1o: \u00bfqu\u00e9 campo(s) identifican sin ambig\u00fcedad? Trat\u00e1 el registro como unidad : encapsul\u00e1 emisiones, cargas y validaciones en subacciones. Para campos continentales , prefer\u00ed tipos expl\u00edcitos (como FECHA ) en vez de tres enteros sueltos.","title":"Buenas pr\u00e1cticas"},{"location":"07-registros/#errores-frecuentes","text":"Omitir asignaci\u00f3n de subcampos en campos continentales (p. ej., setear fecha sin d\u00eda/mes/a\u00f1o ). Duplicados por ausencia de verificaci\u00f3n de clave primaria . Inconsistencias de dominio (p. ej., mes = 16 ) por no validar rangos.","title":"Errores frecuentes"},{"location":"07-registros/#resumen","text":"Un registro modela una entidad con varios campos (posiblemente anidados). Se accede a los campos con un selector ( reg.campo ). Los campos clave son esenciales para identificaci\u00f3n (primaria), relaciones (for\u00e1nea) y acceso (secundaria). Dise\u00f1ar tipos claros y validar dominios mejora la consistencia y facilita su posterior uso en archivos y procesos .","title":"Resumen"},{"location":"08-archivos/","text":"Archivos Esta p\u00e1gina presenta el modelo de archivos aplicado a algoritmos: definici\u00f3n, organizaci\u00f3n f\u00edsica/l\u00f3gica, modos de acceso y el conjunto de sentencias de pseudoc\u00f3digo para abrir, leer, escribir y cerrar archivos. Se incluyen patrones de uso listos para reutilizar. Qu\u00e9 es un archivo Un archivo es un conjunto homog\u00e9neo de registros relacionados entre s\u00ed y organizados para un prop\u00f3sito espec\u00edfico. Un registro est\u00e1 compuesto por campos (simples o compuestos). Los archivos se almacenan en memoria externa (disco, pendrive). Su procesamiento ocurre en memoria interna . Relaci\u00f3n jer\u00e1rquica: Archivo \u2192 Registros \u2192 Campos . Organizaci\u00f3n de archivos (f\u00edsica/l\u00f3gica) Secuencial Registros almacenados consecutivamente . Para acceder al registro n , es necesario pasar por los n\u22121 anteriores. Relativa (directa) El orden f\u00edsico no coincide necesariamente con el orden l\u00f3gico ; el acceso se realiza por posici\u00f3n (relativa) o por una funci\u00f3n de direccionamiento . Indexada Existen dos \u00e1reas : \u00c1rea de datos (primaria) : registros organizados secuencialmente por clave . \u00c1rea de \u00edndices : estructura auxiliar (tabla de \u00edndices) que permite localizar r\u00e1pidamente por clave . Modos de acceso Secuencial : lectura en orden (desde el primero hasta el \u00faltimo). Directo : salta a una posici\u00f3n/clave espec\u00edfica. Mixto : combinaci\u00f3n (p. ej., ubicar por clave y luego leer secuencialmente a partir de all\u00ed). Tipos de datos de apoyo (\u00fatil en definiciones) Tipo conjunto (enumerado) pseudocode Vocal = ('a','e','i','o','u') Estado = ('Libre','Ocupado') * Tipo rango pseudocode Mes = 1..12 Edad = 0..110 Estos tipos facilitan validar dominios al definir campos de un registro . Sentencias de gesti\u00f3n de archivos (pseudoc\u00f3digo) Convenci\u00f3n: Arch es un archivo ; Reg es una variable registro del formato del archivo. Abrir archivo ```pseudocode ABRIR E/(Arch) // modo Entrada (solo lectura) ABRIR /S(Arch) // modo Salida (solo escritura) ``` Leer y detectar fin pseudocode LEER(Arch, Reg) // trae el siguiente registro a 'Reg' FDA(Arch) // Fin De Archivo: verdadero si se lleg\u00f3 al final NFDA(Arch) // No Fin De Archivo: equivalente a NOT FDA(Arch) Escribir y cerrar pseudocode ESCRIBIR(Arch, Reg) // agrega/graba 'Reg' en el archivo (modo Salida) CERRAR(Arch) Nota: algunos modelos did\u00e1cticos usan FDA ; otros proveen NFDA . Eleg\u00ed uno y s\u00e9 consistente (o defin\u00ed NFDA(Arch) := NO FDA(Arch) ). Definiciones en el Ambiente // 1) Formato del registro aRegistro = Registro url: AN(120) fecha_pico: Registro anio: 2000..2100 mes: 1..12 dia: 1..31 FinRegistro reproducciones: N(9) FinRegistro // 2) Variables datos: Archivo de aRegistro ordenado por url // ejemplo ing: aRegistro Patrones de uso (snippets reutilizables) 1) Emisi\u00f3n (listado simple) Recorre un archivo de entrada y emite sus campos. ACCION Listar ES AMBIENTE Arch: Archivo de aRegistro Reg: aRegistro PROCESO ABRIR E/(Arch) LEER(Arch, Reg) Mientras NFDA(Arch) Hacer Esc(Reg.url, ' ', Reg.fecha_pico.dia, '/', Reg.fecha_pico.mes, '/', Reg.fecha_pico.anio, ' ', Reg.reproducciones) LEER(Arch, Reg) FinMientras CERRAR(Arch) FINACCION 2) Carga/Generaci\u00f3n (crear archivo consistente) Crea un archivo nuevo y graba registros ingresados por teclado. ACCION Cargar ES AMBIENTE Nuevo: Archivo de aRegistro ordenado por url Reg: aRegistro cont: entero PROCESO ABRIR /S(Nuevo) cont := 1 Mientras cont <= 100 Hacer Esc('Ingrese url, fecha pico (d m a) y reproducciones:') Leer(Reg.url) Leer(Reg.fecha_pico.dia) Leer(Reg.fecha_pico.mes) Leer(Reg.fecha_pico.anio) Leer(Reg.reproducciones) ESCRIBIR(Nuevo, Reg) cont := cont + 1 FinMientras CERRAR(Nuevo) FINACCION 3) Filtro (generaci\u00f3n a partir de entrada) Lee un archivo de entrada y escribe en salida seg\u00fan una condici\u00f3n. ACCION FiltrarPorFecha ES AMBIENTE In: Archivo de aRegistro Out: Archivo de aRegistro R: aRegistro PROCESO ABRIR E/(In) ABRIR /S(Out) LEER(In, R) Mientras NFDA(In) Hacer Si (R.fecha_pico.mes = 5) y (R.fecha_pico.dia = 1) Entonces ESCRIBIR(Out, R) FinSi LEER(In, R) FinMientras CERRAR(In) CERRAR(Out) FINACCION 4) Transformaci\u00f3n a m\u00faltiples salidas Desv\u00eda los registros a dos archivos distintos. ACCION Particionar ES AMBIENTE In: Archivo de aRegistro Top: Archivo de aRegistro Resto: Archivo de aRegistro R: aRegistro PROCESO ABRIR E/(In) ABRIR /S(Top) ABRIR /S(Resto) LEER(In, R) Mientras NFDA(In) Hacer Si R.reproducciones >= 100000 Entonces ESCRIBIR(Top, R) Contrario ESCRIBIR(Resto, R) FinSi LEER(In, R) FinMientras CERRAR(In) CERRAR(Top) CERRAR(Resto) FINACCION Buenas pr\u00e1cticas Defin\u00ed claramente el formato de registro y los dominios (rangos/enums) de cada campo. Gener\u00e1 archivos consistentes (campos en rango, tipos correctos, claves \u00fanicas si aplica). En emisi\u00f3n/listados, separ\u00e1 lectura , tratamiento y salida para mayor claridad. Cerr\u00e1 siempre archivos con CERRAR para liberar recursos y persistir cambios. Eleg\u00ed el modo de organizaci\u00f3n acorde: secuencial (recorridos completos), relativa (acceso por posici\u00f3n), indexada (b\u00fasqueda por clave). Resumen Un archivo agrupa registros homog\u00e9neos y reside en memoria externa . La organizaci\u00f3n define c\u00f3mo se guardan (secuencial/relativa/indexada) y el acceso c\u00f3mo se leen (secuencial/directo/mixto). Con ABRIR , LEER / ESCRIBIR , FDA / NFDA y CERRAR pod\u00e9s implementar emisi\u00f3n , carga , filtros y transformaciones .","title":"Archivos"},{"location":"08-archivos/#archivos","text":"Esta p\u00e1gina presenta el modelo de archivos aplicado a algoritmos: definici\u00f3n, organizaci\u00f3n f\u00edsica/l\u00f3gica, modos de acceso y el conjunto de sentencias de pseudoc\u00f3digo para abrir, leer, escribir y cerrar archivos. Se incluyen patrones de uso listos para reutilizar.","title":"Archivos"},{"location":"08-archivos/#que-es-un-archivo","text":"Un archivo es un conjunto homog\u00e9neo de registros relacionados entre s\u00ed y organizados para un prop\u00f3sito espec\u00edfico. Un registro est\u00e1 compuesto por campos (simples o compuestos). Los archivos se almacenan en memoria externa (disco, pendrive). Su procesamiento ocurre en memoria interna . Relaci\u00f3n jer\u00e1rquica: Archivo \u2192 Registros \u2192 Campos .","title":"Qu\u00e9 es un archivo"},{"location":"08-archivos/#organizacion-de-archivos-fisicalogica","text":"","title":"Organizaci\u00f3n de archivos (f\u00edsica/l\u00f3gica)"},{"location":"08-archivos/#secuencial","text":"Registros almacenados consecutivamente . Para acceder al registro n , es necesario pasar por los n\u22121 anteriores.","title":"Secuencial"},{"location":"08-archivos/#relativa-directa","text":"El orden f\u00edsico no coincide necesariamente con el orden l\u00f3gico ; el acceso se realiza por posici\u00f3n (relativa) o por una funci\u00f3n de direccionamiento .","title":"Relativa (directa)"},{"location":"08-archivos/#indexada","text":"Existen dos \u00e1reas : \u00c1rea de datos (primaria) : registros organizados secuencialmente por clave . \u00c1rea de \u00edndices : estructura auxiliar (tabla de \u00edndices) que permite localizar r\u00e1pidamente por clave .","title":"Indexada"},{"location":"08-archivos/#modos-de-acceso","text":"Secuencial : lectura en orden (desde el primero hasta el \u00faltimo). Directo : salta a una posici\u00f3n/clave espec\u00edfica. Mixto : combinaci\u00f3n (p. ej., ubicar por clave y luego leer secuencialmente a partir de all\u00ed).","title":"Modos de acceso"},{"location":"08-archivos/#tipos-de-datos-de-apoyo-util-en-definiciones","text":"Tipo conjunto (enumerado) pseudocode Vocal = ('a','e','i','o','u') Estado = ('Libre','Ocupado') * Tipo rango pseudocode Mes = 1..12 Edad = 0..110 Estos tipos facilitan validar dominios al definir campos de un registro .","title":"Tipos de datos de apoyo (\u00fatil en definiciones)"},{"location":"08-archivos/#sentencias-de-gestion-de-archivos-pseudocodigo","text":"Convenci\u00f3n: Arch es un archivo ; Reg es una variable registro del formato del archivo. Abrir archivo ```pseudocode ABRIR E/(Arch) // modo Entrada (solo lectura) ABRIR /S(Arch) // modo Salida (solo escritura) ``` Leer y detectar fin pseudocode LEER(Arch, Reg) // trae el siguiente registro a 'Reg' FDA(Arch) // Fin De Archivo: verdadero si se lleg\u00f3 al final NFDA(Arch) // No Fin De Archivo: equivalente a NOT FDA(Arch) Escribir y cerrar pseudocode ESCRIBIR(Arch, Reg) // agrega/graba 'Reg' en el archivo (modo Salida) CERRAR(Arch) Nota: algunos modelos did\u00e1cticos usan FDA ; otros proveen NFDA . Eleg\u00ed uno y s\u00e9 consistente (o defin\u00ed NFDA(Arch) := NO FDA(Arch) ).","title":"Sentencias de gesti\u00f3n de archivos (pseudoc\u00f3digo)"},{"location":"08-archivos/#definiciones-en-el-ambiente","text":"// 1) Formato del registro aRegistro = Registro url: AN(120) fecha_pico: Registro anio: 2000..2100 mes: 1..12 dia: 1..31 FinRegistro reproducciones: N(9) FinRegistro // 2) Variables datos: Archivo de aRegistro ordenado por url // ejemplo ing: aRegistro","title":"Definiciones en el Ambiente"},{"location":"08-archivos/#patrones-de-uso-snippets-reutilizables","text":"","title":"Patrones de uso (snippets reutilizables)"},{"location":"08-archivos/#1-emision-listado-simple","text":"Recorre un archivo de entrada y emite sus campos. ACCION Listar ES AMBIENTE Arch: Archivo de aRegistro Reg: aRegistro PROCESO ABRIR E/(Arch) LEER(Arch, Reg) Mientras NFDA(Arch) Hacer Esc(Reg.url, ' ', Reg.fecha_pico.dia, '/', Reg.fecha_pico.mes, '/', Reg.fecha_pico.anio, ' ', Reg.reproducciones) LEER(Arch, Reg) FinMientras CERRAR(Arch) FINACCION","title":"1) Emisi\u00f3n (listado simple)"},{"location":"08-archivos/#2-cargageneracion-crear-archivo-consistente","text":"Crea un archivo nuevo y graba registros ingresados por teclado. ACCION Cargar ES AMBIENTE Nuevo: Archivo de aRegistro ordenado por url Reg: aRegistro cont: entero PROCESO ABRIR /S(Nuevo) cont := 1 Mientras cont <= 100 Hacer Esc('Ingrese url, fecha pico (d m a) y reproducciones:') Leer(Reg.url) Leer(Reg.fecha_pico.dia) Leer(Reg.fecha_pico.mes) Leer(Reg.fecha_pico.anio) Leer(Reg.reproducciones) ESCRIBIR(Nuevo, Reg) cont := cont + 1 FinMientras CERRAR(Nuevo) FINACCION","title":"2) Carga/Generaci\u00f3n (crear archivo consistente)"},{"location":"08-archivos/#3-filtro-generacion-a-partir-de-entrada","text":"Lee un archivo de entrada y escribe en salida seg\u00fan una condici\u00f3n. ACCION FiltrarPorFecha ES AMBIENTE In: Archivo de aRegistro Out: Archivo de aRegistro R: aRegistro PROCESO ABRIR E/(In) ABRIR /S(Out) LEER(In, R) Mientras NFDA(In) Hacer Si (R.fecha_pico.mes = 5) y (R.fecha_pico.dia = 1) Entonces ESCRIBIR(Out, R) FinSi LEER(In, R) FinMientras CERRAR(In) CERRAR(Out) FINACCION","title":"3) Filtro (generaci\u00f3n a partir de entrada)"},{"location":"08-archivos/#4-transformacion-a-multiples-salidas","text":"Desv\u00eda los registros a dos archivos distintos. ACCION Particionar ES AMBIENTE In: Archivo de aRegistro Top: Archivo de aRegistro Resto: Archivo de aRegistro R: aRegistro PROCESO ABRIR E/(In) ABRIR /S(Top) ABRIR /S(Resto) LEER(In, R) Mientras NFDA(In) Hacer Si R.reproducciones >= 100000 Entonces ESCRIBIR(Top, R) Contrario ESCRIBIR(Resto, R) FinSi LEER(In, R) FinMientras CERRAR(In) CERRAR(Top) CERRAR(Resto) FINACCION","title":"4) Transformaci\u00f3n a m\u00faltiples salidas"},{"location":"08-archivos/#buenas-practicas","text":"Defin\u00ed claramente el formato de registro y los dominios (rangos/enums) de cada campo. Gener\u00e1 archivos consistentes (campos en rango, tipos correctos, claves \u00fanicas si aplica). En emisi\u00f3n/listados, separ\u00e1 lectura , tratamiento y salida para mayor claridad. Cerr\u00e1 siempre archivos con CERRAR para liberar recursos y persistir cambios. Eleg\u00ed el modo de organizaci\u00f3n acorde: secuencial (recorridos completos), relativa (acceso por posici\u00f3n), indexada (b\u00fasqueda por clave).","title":"Buenas pr\u00e1cticas"},{"location":"08-archivos/#resumen","text":"Un archivo agrupa registros homog\u00e9neos y reside en memoria externa . La organizaci\u00f3n define c\u00f3mo se guardan (secuencial/relativa/indexada) y el acceso c\u00f3mo se leen (secuencial/directo/mixto). Con ABRIR , LEER / ESCRIBIR , FDA / NFDA y CERRAR pod\u00e9s implementar emisi\u00f3n , carga , filtros y transformaciones .","title":"Resumen"},{"location":"09-procesos-archivos/","text":"Procesos con Archivos En esta p\u00e1gina se sistematizan los procesos sobre archivos : validaciones de calidad de datos, procesos individuales y m\u00faltiples , m\u00e1s patrones de pseudoc\u00f3digo listos para reutilizar. Estilo de documentaci\u00f3n: conciso, con ejemplos ejecutables en pseudoc\u00f3digo. Calidad de datos en archivos Antes de procesar, verific\u00e1 consistencia y congruencia de los registros. Consistencia : cada campo respeta su formato y dominio (rango o conjunto permitido). Ej.: FECHA = {anio: 2000..2100, mes: 1..12, dia: 1..31} . Congruencia : la combinaci\u00f3n de campos es v\u00e1lida entre s\u00ed . Ej.: 31/02/2024 es incongruente aunque cada campo, por separado, tiene n\u00fameros v\u00e1lidos. Tipos de validaci\u00f3n Gruesa (intra\u2011registro) : entre campos del mismo registro (p. ej., fecha v\u00e1lida del calendario ). Fina (inter\u2011archivo) : entre campos de archivos distintos (p. ej., DNI en Comisiones existe en Legajos ). Snippet: validaci\u00f3n de fecha FUNCION FechaValida(f: FECHA): logico devolver (2000 <= f.anio <= 2100) y (1 <= f.mes <= 12) y (1 <= f.dia <= 31) y ((f.mes en {1,3,5,7,8,10,12} y f.dia <= 31) o (f.mes en {4,6,9,11} y f.dia <= 30) o (f.mes = 2 y f.dia <= 29)) // simple: admite 29 sin chequear bisiesto FINFUNCION \u00bfQu\u00e9 es un proceso? Conjunto de operaciones que transforman datos de entrada (archivos) en resultados (salidas/archivos/listados). Al dise\u00f1ar, defin\u00ed: Entradas (fuentes, orden, claves) Transformaciones (reglas, acumulaciones, cortes) Salidas (listados, padrones, archivos generados) Clasificaci\u00f3n general Procesos individuales Un solo archivo de entrada y 0 o 1 archivo de salida . Tipos frecuentes Carga/Generaci\u00f3n (crear archivo consistente) Emisi\u00f3n/Listador (salida impresa) Padr\u00f3n (listador + totales finales ) Corte de control (padrones con totales parciales ; ver p\u00e1gina 10\u2011corte\u2011control ) Estad\u00edsticos (contabilizar por categor\u00edas con tabla de frecuencias) Procesos m\u00faltiples Varios archivos de entrada y/o salida. Tipos frecuentes Apareo (merge) de archivos ordenados por la misma clave Intersecci\u00f3n/Uni\u00f3n/Diferencia entre archivos ordenados Maestro\u2013Detalle (actualizaciones) Generaci\u00f3n transformadora (split/partition a m\u00faltiples salidas) Patrones de procesos individuales 1) Carga (generaci\u00f3n de archivo) ACCION Carga ES AMBIENTE TIPO REG = Registro clave: AN(13) fecha: FECHA valor: N(9) FinRegistro Nuevo: Archivo de REG ordenado por clave R: REG i: entero PROCESO ABRIR /S(Nuevo) Para i := 1 Hasta 100 Hacer Esc(\"clave, dia, mes, anio, valor:\") Leer(R.clave); Leer(R.fecha.dia); Leer(R.fecha.mes); Leer(R.fecha.anio); Leer(R.valor) Si FechaValida(R.fecha) Entonces ESCRIBIR(Nuevo, R) FinSi FinPara CERRAR(Nuevo) FINACCION 2) Emisi\u00f3n / Listador ACCION Listar ES AMBIENTE A: Archivo de REG R: REG PROCESO ABRIR E/(A) LEER(A, R) Mientras NFDA(A) Hacer Esc(R.clave, R.fecha.dia, '/', R.fecha.mes, '/', R.fecha.anio, R.valor) LEER(A, R) FinMientras CERRAR(A) FINACCION 3) Padr\u00f3n (totales finales) ACCION Padron ES AMBIENTE A: Archivo de REG ordenado por clave R: REG total: entero PROCESO total := 0 ABRIR E/(A) LEER(A, R) Mientras NFDA(A) Hacer Esc(R.clave, R.valor) total := total + 1 LEER(A, R) FinMientras Esc(\"Total de registros:\", total) CERRAR(A) FINACCION 4) Estad\u00edstico con tabla de frecuencias ACCION EstadisticoPorMes ES AMBIENTE A: Archivo de REG R: REG freq: arreglo[1..12] de entero m: entero PROCESO Para m := 1 Hasta 12 Hacer freq[m] := 0 FinPara ABRIR E/(A); LEER(A, R) Mientras NFDA(A) Hacer freq[R.fecha.mes] := freq[R.fecha.mes] + 1 LEER(A, R) FinMientras; CERRAR(A) Para m := 1 Hasta 12 Hacer Esc(\"Mes\", m, \":\", freq[m]) FinPara FINACCION Corte de control se desarrolla con detalle en 10\u2011corte\u2011control.md (totales por niveles de clave ). Patrones de procesos m\u00faltiples 5) Apareo (merge) de dos archivos ordenados por la misma clave Combina A y B (ambos ordenados ) en C . ACCION Apareo ES AMBIENTE A, B, C: Archivo de REG // todos ordenados por 'clave' RA, RB: REG PROCESO ABRIR E/(A); ABRIR E/(B); ABRIR /S(C) LEER(A, RA); LEER(B, RB) Mientras NFDA(A) y NFDA(B) Hacer Si RA.clave < RB.clave Entonces ESCRIBIR(C, RA); LEER(A, RA) Sino Si RB.clave < RA.clave Entonces ESCRIBIR(C, RB); LEER(B, RB) Sino // claves iguales \u2192 decidir pol\u00edtica (p.ej., preferir A) ESCRIBIR(C, RA); LEER(A, RA); LEER(B, RB) FinSi FinMientras // arrastre Mientras NFDA(A) Hacer ESCRIBIR(C, RA); LEER(A, RA) FinMientras Mientras NFDA(B) Hacer ESCRIBIR(C, RB); LEER(B, RB) FinMientras CERRAR(A); CERRAR(B); CERRAR(C) FINACCION 6) Intersecci\u00f3n (claves comunes) de dos archivos ordenados ACCION Interseccion ES AMBIENTE A, B, C: Archivo de REG // C = comunes RA, RB: REG PROCESO ABRIR E/(A); ABRIR E/(B); ABRIR /S(C) LEER(A, RA); LEER(B, RB) Mientras NFDA(A) y NFDA(B) Hacer Si RA.clave = RB.clave Entonces ESCRIBIR(C, RA) LEER(A, RA); LEER(B, RB) Sino Si RA.clave < RB.clave Entonces LEER(A, RA) Sino LEER(B, RB) FinSi FinMientras CERRAR(A); CERRAR(B); CERRAR(C) FINACCION 7) Maestro\u2013Detalle (actualizaci\u00f3n) Actualiza Maestro con movimientos de Detalle (ambos ordenados por clave ). ACCION MaestroDetalle ES AMBIENTE Maestro: Archivo de REG Detalle: Archivo de RegistroMov // {clave, delta} Salida: Archivo de REG RM: REG; RD: RegistroMov PROCESO ABRIR E/(Maestro); ABRIR E/(Detalle); ABRIR /S(Salida) LEER(Maestro, RM); LEER(Detalle, RD) Mientras NFDA(Maestro) Hacer Mientras NFDA(Detalle) y RD.clave < RM.clave Hacer LEER(Detalle, RD) FinMientras Mientras NFDA(Detalle) y RD.clave = RM.clave Hacer RM.valor := RM.valor + RD.delta LEER(Detalle, RD) FinMientras ESCRIBIR(Salida, RM) LEER(Maestro, RM) FinMientras CERRAR(Maestro); CERRAR(Detalle); CERRAR(Salida) FINACCION Variantes: Uni\u00f3n (todos los de A y B), Diferencia (de A no presentes en B), Join por clave compuesta. Buenas pr\u00e1cticas Precondiciones : exig\u00ed orden por clave y defin\u00ed pol\u00edtica para claves duplicadas. Lectura anticipada + bucles con NFDA evitan leer fuera de rango . Separ\u00e1 responsabilidades : leer \u2192 tratar \u2192 emitir. Para estad\u00edsticas, eleg\u00ed estructuras internas (vectores/tablas) con dominios acotados . Document\u00e1 invariantes (p. ej., \u201cA y B est\u00e1n ordenados por clave \u201d). Resumen Distingu\u00ed procesos individuales (carga, emisi\u00f3n, padr\u00f3n, estad\u00edstico, corte de control) y m\u00faltiples (apareo, intersecci\u00f3n, maestro\u2013detalle). Asegur\u00e1 consistencia y congruencia antes de procesar. Los patrones de esta p\u00e1gina cubren los casos m\u00e1s comunes y son base para dise\u00f1os m\u00e1s complejos (balanceos, consolidaciones, joins).","title":"Procesos con Archivos"},{"location":"09-procesos-archivos/#procesos-con-archivos","text":"En esta p\u00e1gina se sistematizan los procesos sobre archivos : validaciones de calidad de datos, procesos individuales y m\u00faltiples , m\u00e1s patrones de pseudoc\u00f3digo listos para reutilizar. Estilo de documentaci\u00f3n: conciso, con ejemplos ejecutables en pseudoc\u00f3digo.","title":"Procesos con Archivos"},{"location":"09-procesos-archivos/#calidad-de-datos-en-archivos","text":"Antes de procesar, verific\u00e1 consistencia y congruencia de los registros. Consistencia : cada campo respeta su formato y dominio (rango o conjunto permitido). Ej.: FECHA = {anio: 2000..2100, mes: 1..12, dia: 1..31} . Congruencia : la combinaci\u00f3n de campos es v\u00e1lida entre s\u00ed . Ej.: 31/02/2024 es incongruente aunque cada campo, por separado, tiene n\u00fameros v\u00e1lidos.","title":"Calidad de datos en archivos"},{"location":"09-procesos-archivos/#tipos-de-validacion","text":"Gruesa (intra\u2011registro) : entre campos del mismo registro (p. ej., fecha v\u00e1lida del calendario ). Fina (inter\u2011archivo) : entre campos de archivos distintos (p. ej., DNI en Comisiones existe en Legajos ).","title":"Tipos de validaci\u00f3n"},{"location":"09-procesos-archivos/#snippet-validacion-de-fecha","text":"FUNCION FechaValida(f: FECHA): logico devolver (2000 <= f.anio <= 2100) y (1 <= f.mes <= 12) y (1 <= f.dia <= 31) y ((f.mes en {1,3,5,7,8,10,12} y f.dia <= 31) o (f.mes en {4,6,9,11} y f.dia <= 30) o (f.mes = 2 y f.dia <= 29)) // simple: admite 29 sin chequear bisiesto FINFUNCION","title":"Snippet: validaci\u00f3n de fecha"},{"location":"09-procesos-archivos/#que-es-un-proceso","text":"Conjunto de operaciones que transforman datos de entrada (archivos) en resultados (salidas/archivos/listados). Al dise\u00f1ar, defin\u00ed: Entradas (fuentes, orden, claves) Transformaciones (reglas, acumulaciones, cortes) Salidas (listados, padrones, archivos generados)","title":"\u00bfQu\u00e9 es un proceso?"},{"location":"09-procesos-archivos/#clasificacion-general","text":"","title":"Clasificaci\u00f3n general"},{"location":"09-procesos-archivos/#procesos-individuales","text":"Un solo archivo de entrada y 0 o 1 archivo de salida . Tipos frecuentes Carga/Generaci\u00f3n (crear archivo consistente) Emisi\u00f3n/Listador (salida impresa) Padr\u00f3n (listador + totales finales ) Corte de control (padrones con totales parciales ; ver p\u00e1gina 10\u2011corte\u2011control ) Estad\u00edsticos (contabilizar por categor\u00edas con tabla de frecuencias)","title":"Procesos individuales"},{"location":"09-procesos-archivos/#procesos-multiples","text":"Varios archivos de entrada y/o salida. Tipos frecuentes Apareo (merge) de archivos ordenados por la misma clave Intersecci\u00f3n/Uni\u00f3n/Diferencia entre archivos ordenados Maestro\u2013Detalle (actualizaciones) Generaci\u00f3n transformadora (split/partition a m\u00faltiples salidas)","title":"Procesos m\u00faltiples"},{"location":"09-procesos-archivos/#patrones-de-procesos-individuales","text":"","title":"Patrones de procesos individuales"},{"location":"09-procesos-archivos/#1-carga-generacion-de-archivo","text":"ACCION Carga ES AMBIENTE TIPO REG = Registro clave: AN(13) fecha: FECHA valor: N(9) FinRegistro Nuevo: Archivo de REG ordenado por clave R: REG i: entero PROCESO ABRIR /S(Nuevo) Para i := 1 Hasta 100 Hacer Esc(\"clave, dia, mes, anio, valor:\") Leer(R.clave); Leer(R.fecha.dia); Leer(R.fecha.mes); Leer(R.fecha.anio); Leer(R.valor) Si FechaValida(R.fecha) Entonces ESCRIBIR(Nuevo, R) FinSi FinPara CERRAR(Nuevo) FINACCION","title":"1) Carga (generaci\u00f3n de archivo)"},{"location":"09-procesos-archivos/#2-emision-listador","text":"ACCION Listar ES AMBIENTE A: Archivo de REG R: REG PROCESO ABRIR E/(A) LEER(A, R) Mientras NFDA(A) Hacer Esc(R.clave, R.fecha.dia, '/', R.fecha.mes, '/', R.fecha.anio, R.valor) LEER(A, R) FinMientras CERRAR(A) FINACCION","title":"2) Emisi\u00f3n / Listador"},{"location":"09-procesos-archivos/#3-padron-totales-finales","text":"ACCION Padron ES AMBIENTE A: Archivo de REG ordenado por clave R: REG total: entero PROCESO total := 0 ABRIR E/(A) LEER(A, R) Mientras NFDA(A) Hacer Esc(R.clave, R.valor) total := total + 1 LEER(A, R) FinMientras Esc(\"Total de registros:\", total) CERRAR(A) FINACCION","title":"3) Padr\u00f3n (totales finales)"},{"location":"09-procesos-archivos/#4-estadistico-con-tabla-de-frecuencias","text":"ACCION EstadisticoPorMes ES AMBIENTE A: Archivo de REG R: REG freq: arreglo[1..12] de entero m: entero PROCESO Para m := 1 Hasta 12 Hacer freq[m] := 0 FinPara ABRIR E/(A); LEER(A, R) Mientras NFDA(A) Hacer freq[R.fecha.mes] := freq[R.fecha.mes] + 1 LEER(A, R) FinMientras; CERRAR(A) Para m := 1 Hasta 12 Hacer Esc(\"Mes\", m, \":\", freq[m]) FinPara FINACCION Corte de control se desarrolla con detalle en 10\u2011corte\u2011control.md (totales por niveles de clave ).","title":"4) Estad\u00edstico con tabla de frecuencias"},{"location":"09-procesos-archivos/#patrones-de-procesos-multiples","text":"","title":"Patrones de procesos m\u00faltiples"},{"location":"09-procesos-archivos/#5-apareo-merge-de-dos-archivos-ordenados-por-la-misma-clave","text":"Combina A y B (ambos ordenados ) en C . ACCION Apareo ES AMBIENTE A, B, C: Archivo de REG // todos ordenados por 'clave' RA, RB: REG PROCESO ABRIR E/(A); ABRIR E/(B); ABRIR /S(C) LEER(A, RA); LEER(B, RB) Mientras NFDA(A) y NFDA(B) Hacer Si RA.clave < RB.clave Entonces ESCRIBIR(C, RA); LEER(A, RA) Sino Si RB.clave < RA.clave Entonces ESCRIBIR(C, RB); LEER(B, RB) Sino // claves iguales \u2192 decidir pol\u00edtica (p.ej., preferir A) ESCRIBIR(C, RA); LEER(A, RA); LEER(B, RB) FinSi FinMientras // arrastre Mientras NFDA(A) Hacer ESCRIBIR(C, RA); LEER(A, RA) FinMientras Mientras NFDA(B) Hacer ESCRIBIR(C, RB); LEER(B, RB) FinMientras CERRAR(A); CERRAR(B); CERRAR(C) FINACCION","title":"5) Apareo (merge) de dos archivos ordenados por la misma clave"},{"location":"09-procesos-archivos/#6-interseccion-claves-comunes-de-dos-archivos-ordenados","text":"ACCION Interseccion ES AMBIENTE A, B, C: Archivo de REG // C = comunes RA, RB: REG PROCESO ABRIR E/(A); ABRIR E/(B); ABRIR /S(C) LEER(A, RA); LEER(B, RB) Mientras NFDA(A) y NFDA(B) Hacer Si RA.clave = RB.clave Entonces ESCRIBIR(C, RA) LEER(A, RA); LEER(B, RB) Sino Si RA.clave < RB.clave Entonces LEER(A, RA) Sino LEER(B, RB) FinSi FinMientras CERRAR(A); CERRAR(B); CERRAR(C) FINACCION","title":"6) Intersecci\u00f3n (claves comunes) de dos archivos ordenados"},{"location":"09-procesos-archivos/#7-maestrodetalle-actualizacion","text":"Actualiza Maestro con movimientos de Detalle (ambos ordenados por clave ). ACCION MaestroDetalle ES AMBIENTE Maestro: Archivo de REG Detalle: Archivo de RegistroMov // {clave, delta} Salida: Archivo de REG RM: REG; RD: RegistroMov PROCESO ABRIR E/(Maestro); ABRIR E/(Detalle); ABRIR /S(Salida) LEER(Maestro, RM); LEER(Detalle, RD) Mientras NFDA(Maestro) Hacer Mientras NFDA(Detalle) y RD.clave < RM.clave Hacer LEER(Detalle, RD) FinMientras Mientras NFDA(Detalle) y RD.clave = RM.clave Hacer RM.valor := RM.valor + RD.delta LEER(Detalle, RD) FinMientras ESCRIBIR(Salida, RM) LEER(Maestro, RM) FinMientras CERRAR(Maestro); CERRAR(Detalle); CERRAR(Salida) FINACCION Variantes: Uni\u00f3n (todos los de A y B), Diferencia (de A no presentes en B), Join por clave compuesta.","title":"7) Maestro\u2013Detalle (actualizaci\u00f3n)"},{"location":"09-procesos-archivos/#buenas-practicas","text":"Precondiciones : exig\u00ed orden por clave y defin\u00ed pol\u00edtica para claves duplicadas. Lectura anticipada + bucles con NFDA evitan leer fuera de rango . Separ\u00e1 responsabilidades : leer \u2192 tratar \u2192 emitir. Para estad\u00edsticas, eleg\u00ed estructuras internas (vectores/tablas) con dominios acotados . Document\u00e1 invariantes (p. ej., \u201cA y B est\u00e1n ordenados por clave \u201d).","title":"Buenas pr\u00e1cticas"},{"location":"09-procesos-archivos/#resumen","text":"Distingu\u00ed procesos individuales (carga, emisi\u00f3n, padr\u00f3n, estad\u00edstico, corte de control) y m\u00faltiples (apareo, intersecci\u00f3n, maestro\u2013detalle). Asegur\u00e1 consistencia y congruencia antes de procesar. Los patrones de esta p\u00e1gina cubren los casos m\u00e1s comunes y son base para dise\u00f1os m\u00e1s complejos (balanceos, consolidaciones, joins).","title":"Resumen"},{"location":"10-corte-control/","text":"Corte de Control El corte de control es un proceso individual sobre archivos que permite emitir informaci\u00f3n jer\u00e1rquica con totales parciales por niveles de clave y total general . Es una especializaci\u00f3n de los padrones (listados) donde, adem\u00e1s de recorrer, agrupamos y acumulamos por campos. \u26a0\ufe0f No todos los problemas se resuelven con corte de control. Se aplica cuando necesit\u00e1s agregar (contar, sumar, min/max, etc.) por grupos definidos por claves . Requisitos indispensables Clave compleja que identifique la jerarqu\u00eda de agrupaci\u00f3n (uno o m\u00e1s campos). Archivo ordenado por los campos de corte (en el orden jer\u00e1rquico que se va a informar). Si el informe es por Ciudad \u2192 Raza , el archivo debe estar ordenado por Ciudad y Raza . Si es por Mes \u2192 Tipo (p. ej., sat\u00e9lites por mes y por tipo), debe estar ordenado por Mes y Tipo . Si los datos no est\u00e1n ordenados , primero hay que ordenarlos o usar otro enfoque. Anatom\u00eda del algoritmo Resguardo de claves : variables que guardan la clave actual (p. ej., res_ciu , res_raza ). Totalizadores por nivel : tot_raza , tot_ciu , tot_gral , etc. Lectura anticipada : leer el primer registro para inicializar resguardos y entrar al bucle. Verificaci\u00f3n de corte : antes de tratar un registro, comparar sus claves con los resguardos. Cortes por niveles : al cambiar un nivel superior , primero cerrar (emitir y reiniciar) los niveles inferiores . Cierre final : al terminar el recorrido, forzar los cortes pendientes y emitir total general . Patr\u00f3n base (1 nivel de corte) ACCION Corte1 ES AMBIENTE REG = Registro clave: ... // campo de agrupaci\u00f3n valor: ... // campo a acumular/contar FinRegistro A: Archivo de REG ordenado por clave R: REG res_clave: ... tot_nivel, tot_gral: entero SUBACCION VER_CORTE ES Si R.clave <> res_clave Entonces CORTE_NIVEL FinSi FINSUBACCION SUBACCION CORTE_NIVEL ES Esc(\"Total para \", res_clave, \": \", tot_nivel) tot_gral := tot_gral + tot_nivel tot_nivel := 0 res_clave := R.clave FINSUBACCION SUBACCION TRATAR_REGISTRO ES // ejemplo: contar 1 por registro tot_nivel := tot_nivel + 1 FINSUBACCION PROCESO tot_nivel := 0; tot_gral := 0 ABRIR E/(A) LEER(A, R) Si NFDA(A) Entonces res_clave := R.clave // resguardo inicial Mientras NFDA(A) Hacer VER_CORTE // corta si cambi\u00f3 la clave TRATAR_REGISTRO LEER(A, R) FinMientras CORTE_NIVEL // cierre del \u00faltimo grupo Esc(\"Total general: \", tot_gral) FinSi CERRAR(A) FINACCION Idea : ver corte \u2192 tratar \u2192 leer . El orden ayuda a detectar el cambio antes de acumular en el grupo equivocado. Patr\u00f3n de 2 niveles (Nivel 2 \u2192 Nivel 1) Ejemplo cl\u00e1sico: Ciudad (nivel 2) \u2192 Raza (nivel 1) . Contar mascotas con peso > 5 kg por Raza y Ciudad , y total general. ACCION Corte2 ES AMBIENTE Mascota = Registro Clave = Registro Ciudad: AN(30) Raza: AN(20) Nombre: AN(30) FinRegistro Color: AN(10) Peso: N(4,2) FinRegistro A: Archivo de Mascota ordenado por Clave.Ciudad, Clave.Raza M: Mascota res_ciu: AN(30) res_raza: AN(20) tot_raza, tot_ciu, tot_gral: entero SUBACCION VER_CORTE ES Si M.Clave.Ciudad <> res_ciu Entonces CORTE_CIUDAD Sino Si M.Clave.Raza <> res_raza Entonces CORTE_RAZA FinSi FINSUBACCION SUBACCION CORTE_RAZA ES Esc(\"Total en ciudad \", res_ciu, \" de raza \", res_raza, \": \", tot_raza) tot_ciu := tot_ciu + tot_raza tot_raza := 0 res_raza := M.Clave.Raza FINSUBACCION SUBACCION CORTE_CIUDAD ES CORTE_RAZA // primero cerrar nivel inferior Esc(\"Total en ciudad \", res_ciu, \": \", tot_ciu) tot_gral := tot_gral + tot_ciu tot_ciu := 0 res_ciu := M.Clave.Ciudad FINSUBACCION SUBACCION TRATAR_REGISTRO ES Si M.Peso > 5 Entonces tot_raza := tot_raza + 1 FinSi FINSUBACCION PROCESO tot_raza := 0; tot_ciu := 0; tot_gral := 0 ABRIR E/(A) LEER(A, M) Si NFDA(A) Entonces res_ciu := M.Clave.Ciudad res_raza := M.Clave.Raza Mientras NFDA(A) Hacer VER_CORTE TRATAR_REGISTRO LEER(A, M) FinMientras CORTE_CIUDAD // cierre del \u00faltimo bloque (propaga corte de raza) Esc(\"Total general (>5 kg): \", tot_gral) FinSi CERRAR(A) FINACCION Regla de oro : cuando cambia un nivel superior , hay que cerrar primero todos los niveles inferiores . Patr\u00f3n de 3+ niveles (escalable) La idea se generaliza: VER_CORTE compara desde el nivel m\u00e1s alto al m\u00e1s bajo ; cada CORTE_k llama al corte del nivel inmediato inferior antes de emitir y reiniciar su totalizador. // Esqueleto para N niveles (L3 > L2 > L1) // Si cambia L3 \u2192 CORTE_L3 (que llama a CORTE_L2 \u2192 que llama a CORTE_L1) // Si cambia L2 \u2192 CORTE_L2 (que llama a CORTE_L1) // Si cambia L1 \u2192 CORTE_L1 En informes complejos, conviene modularizar cortes por nivel y mantener nombres claros ( res_l1 , tot_l1 , etc.). Variantes de tratamiento Conteos (registros, casos que cumplen una condici\u00f3n) Sumas (acumular un campo num\u00e9rico) Min/Max (acompa\u00f1ados de la clave del mejor/peor) Promedios (sumas + conteos por nivel) Porcentajes (necesitan conocer tot_nivel y tot_superior ) El bloque TRATAR_REGISTRO cambia seg\u00fan la m\u00e9trica. Casos de aplicaci\u00f3n y no aplicaci\u00f3n \u2714\ufe0f Aplicaci\u00f3n : \u201cEmitir totales de sat\u00e9lites por mes y por tipo \u201d \u2192 ordenar por Mes, Tipo . \u274c No aplicaci\u00f3n (tal cual): \u201cTotales de sat\u00e9lites en diciembre (sin agrupar)\u201d \u2192 alcanza con filtro + padr\u00f3n . Errores frecuentes Archivo mal ordenado respecto de las claves de corte. Olvidar el cierre final de cortes \u2192 se pierde el \u00faltimo grupo. Inicializaciones incorrectas de resguardos/totalizadores. Orden de verificaci\u00f3n err\u00f3neo: cortar inferior antes que superior. Tratar antes de VER_CORTE \u2192 contamina el grupo anterior. Checklist r\u00e1pido [ ] \u00bfDefiniste clave(s) y orden del archivo? [ ] \u00bfHiciste lectura anticipada y resguardaste claves? [ ] \u00bfInvoc\u00e1s VER_CORTE antes de TRATAR_REGISTRO ? [ ] \u00bfLos cortes se emiten de abajo hacia arriba (L1\u2192L2\u2192...)? [ ] \u00bfForz\u00e1s el cierre final al terminar? Resumen El corte de control estructura informes jer\u00e1rquicos por grupos : requiere clave compleja y archivo ordenado . Su patr\u00f3n esencial es: leer \u2192 ver corte \u2192 tratar \u2192 leer , con cortes en cascada desde el nivel inferior al superior y un cierre final que emite totales pendientes y el total general .","title":"Corte de Control"},{"location":"10-corte-control/#corte-de-control","text":"El corte de control es un proceso individual sobre archivos que permite emitir informaci\u00f3n jer\u00e1rquica con totales parciales por niveles de clave y total general . Es una especializaci\u00f3n de los padrones (listados) donde, adem\u00e1s de recorrer, agrupamos y acumulamos por campos. \u26a0\ufe0f No todos los problemas se resuelven con corte de control. Se aplica cuando necesit\u00e1s agregar (contar, sumar, min/max, etc.) por grupos definidos por claves .","title":"Corte de Control"},{"location":"10-corte-control/#requisitos-indispensables","text":"Clave compleja que identifique la jerarqu\u00eda de agrupaci\u00f3n (uno o m\u00e1s campos). Archivo ordenado por los campos de corte (en el orden jer\u00e1rquico que se va a informar). Si el informe es por Ciudad \u2192 Raza , el archivo debe estar ordenado por Ciudad y Raza . Si es por Mes \u2192 Tipo (p. ej., sat\u00e9lites por mes y por tipo), debe estar ordenado por Mes y Tipo . Si los datos no est\u00e1n ordenados , primero hay que ordenarlos o usar otro enfoque.","title":"Requisitos indispensables"},{"location":"10-corte-control/#anatomia-del-algoritmo","text":"Resguardo de claves : variables que guardan la clave actual (p. ej., res_ciu , res_raza ). Totalizadores por nivel : tot_raza , tot_ciu , tot_gral , etc. Lectura anticipada : leer el primer registro para inicializar resguardos y entrar al bucle. Verificaci\u00f3n de corte : antes de tratar un registro, comparar sus claves con los resguardos. Cortes por niveles : al cambiar un nivel superior , primero cerrar (emitir y reiniciar) los niveles inferiores . Cierre final : al terminar el recorrido, forzar los cortes pendientes y emitir total general .","title":"Anatom\u00eda del algoritmo"},{"location":"10-corte-control/#patron-base-1-nivel-de-corte","text":"ACCION Corte1 ES AMBIENTE REG = Registro clave: ... // campo de agrupaci\u00f3n valor: ... // campo a acumular/contar FinRegistro A: Archivo de REG ordenado por clave R: REG res_clave: ... tot_nivel, tot_gral: entero SUBACCION VER_CORTE ES Si R.clave <> res_clave Entonces CORTE_NIVEL FinSi FINSUBACCION SUBACCION CORTE_NIVEL ES Esc(\"Total para \", res_clave, \": \", tot_nivel) tot_gral := tot_gral + tot_nivel tot_nivel := 0 res_clave := R.clave FINSUBACCION SUBACCION TRATAR_REGISTRO ES // ejemplo: contar 1 por registro tot_nivel := tot_nivel + 1 FINSUBACCION PROCESO tot_nivel := 0; tot_gral := 0 ABRIR E/(A) LEER(A, R) Si NFDA(A) Entonces res_clave := R.clave // resguardo inicial Mientras NFDA(A) Hacer VER_CORTE // corta si cambi\u00f3 la clave TRATAR_REGISTRO LEER(A, R) FinMientras CORTE_NIVEL // cierre del \u00faltimo grupo Esc(\"Total general: \", tot_gral) FinSi CERRAR(A) FINACCION Idea : ver corte \u2192 tratar \u2192 leer . El orden ayuda a detectar el cambio antes de acumular en el grupo equivocado.","title":"Patr\u00f3n base (1 nivel de corte)"},{"location":"10-corte-control/#patron-de-2-niveles-nivel-2-nivel-1","text":"Ejemplo cl\u00e1sico: Ciudad (nivel 2) \u2192 Raza (nivel 1) . Contar mascotas con peso > 5 kg por Raza y Ciudad , y total general. ACCION Corte2 ES AMBIENTE Mascota = Registro Clave = Registro Ciudad: AN(30) Raza: AN(20) Nombre: AN(30) FinRegistro Color: AN(10) Peso: N(4,2) FinRegistro A: Archivo de Mascota ordenado por Clave.Ciudad, Clave.Raza M: Mascota res_ciu: AN(30) res_raza: AN(20) tot_raza, tot_ciu, tot_gral: entero SUBACCION VER_CORTE ES Si M.Clave.Ciudad <> res_ciu Entonces CORTE_CIUDAD Sino Si M.Clave.Raza <> res_raza Entonces CORTE_RAZA FinSi FINSUBACCION SUBACCION CORTE_RAZA ES Esc(\"Total en ciudad \", res_ciu, \" de raza \", res_raza, \": \", tot_raza) tot_ciu := tot_ciu + tot_raza tot_raza := 0 res_raza := M.Clave.Raza FINSUBACCION SUBACCION CORTE_CIUDAD ES CORTE_RAZA // primero cerrar nivel inferior Esc(\"Total en ciudad \", res_ciu, \": \", tot_ciu) tot_gral := tot_gral + tot_ciu tot_ciu := 0 res_ciu := M.Clave.Ciudad FINSUBACCION SUBACCION TRATAR_REGISTRO ES Si M.Peso > 5 Entonces tot_raza := tot_raza + 1 FinSi FINSUBACCION PROCESO tot_raza := 0; tot_ciu := 0; tot_gral := 0 ABRIR E/(A) LEER(A, M) Si NFDA(A) Entonces res_ciu := M.Clave.Ciudad res_raza := M.Clave.Raza Mientras NFDA(A) Hacer VER_CORTE TRATAR_REGISTRO LEER(A, M) FinMientras CORTE_CIUDAD // cierre del \u00faltimo bloque (propaga corte de raza) Esc(\"Total general (>5 kg): \", tot_gral) FinSi CERRAR(A) FINACCION Regla de oro : cuando cambia un nivel superior , hay que cerrar primero todos los niveles inferiores .","title":"Patr\u00f3n de 2 niveles (Nivel 2 \u2192 Nivel 1)"},{"location":"10-corte-control/#patron-de-3-niveles-escalable","text":"La idea se generaliza: VER_CORTE compara desde el nivel m\u00e1s alto al m\u00e1s bajo ; cada CORTE_k llama al corte del nivel inmediato inferior antes de emitir y reiniciar su totalizador. // Esqueleto para N niveles (L3 > L2 > L1) // Si cambia L3 \u2192 CORTE_L3 (que llama a CORTE_L2 \u2192 que llama a CORTE_L1) // Si cambia L2 \u2192 CORTE_L2 (que llama a CORTE_L1) // Si cambia L1 \u2192 CORTE_L1 En informes complejos, conviene modularizar cortes por nivel y mantener nombres claros ( res_l1 , tot_l1 , etc.).","title":"Patr\u00f3n de 3+ niveles (escalable)"},{"location":"10-corte-control/#variantes-de-tratamiento","text":"Conteos (registros, casos que cumplen una condici\u00f3n) Sumas (acumular un campo num\u00e9rico) Min/Max (acompa\u00f1ados de la clave del mejor/peor) Promedios (sumas + conteos por nivel) Porcentajes (necesitan conocer tot_nivel y tot_superior ) El bloque TRATAR_REGISTRO cambia seg\u00fan la m\u00e9trica.","title":"Variantes de tratamiento"},{"location":"10-corte-control/#casos-de-aplicacion-y-no-aplicacion","text":"\u2714\ufe0f Aplicaci\u00f3n : \u201cEmitir totales de sat\u00e9lites por mes y por tipo \u201d \u2192 ordenar por Mes, Tipo . \u274c No aplicaci\u00f3n (tal cual): \u201cTotales de sat\u00e9lites en diciembre (sin agrupar)\u201d \u2192 alcanza con filtro + padr\u00f3n .","title":"Casos de aplicaci\u00f3n y no aplicaci\u00f3n"},{"location":"10-corte-control/#errores-frecuentes","text":"Archivo mal ordenado respecto de las claves de corte. Olvidar el cierre final de cortes \u2192 se pierde el \u00faltimo grupo. Inicializaciones incorrectas de resguardos/totalizadores. Orden de verificaci\u00f3n err\u00f3neo: cortar inferior antes que superior. Tratar antes de VER_CORTE \u2192 contamina el grupo anterior.","title":"Errores frecuentes"},{"location":"10-corte-control/#checklist-rapido","text":"[ ] \u00bfDefiniste clave(s) y orden del archivo? [ ] \u00bfHiciste lectura anticipada y resguardaste claves? [ ] \u00bfInvoc\u00e1s VER_CORTE antes de TRATAR_REGISTRO ? [ ] \u00bfLos cortes se emiten de abajo hacia arriba (L1\u2192L2\u2192...)? [ ] \u00bfForz\u00e1s el cierre final al terminar?","title":"Checklist r\u00e1pido"},{"location":"10-corte-control/#resumen","text":"El corte de control estructura informes jer\u00e1rquicos por grupos : requiere clave compleja y archivo ordenado . Su patr\u00f3n esencial es: leer \u2192 ver corte \u2192 tratar \u2192 leer , con cortes en cascada desde el nivel inferior al superior y un cierre final que emite totales pendientes y el total general .","title":"Resumen"}]}